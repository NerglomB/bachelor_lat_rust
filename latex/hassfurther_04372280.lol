\contentsline {lstlisting}{\numberline {1}Einführendes Beispiel: struct}{9}{lstlisting.1}%
\contentsline {lstlisting}{\numberline {2}Einführendes Beispiel: Ownership abgeben}{9}{lstlisting.2}%
\contentsline {lstlisting}{\numberline {3}Einführendes Beispiel: Ownership zurückgeben}{10}{lstlisting.3}%
\contentsline {lstlisting}{\numberline {4}Einführendes Beispiel: Unveränderliche Referenz}{10}{lstlisting.4}%
\contentsline {lstlisting}{\numberline {5}Einführendes Beispiel: Veränderliche Referenz}{10}{lstlisting.5}%
\contentsline {lstlisting}{\numberline {6}Expression Einführendes Beispiel:}{11}{lstlisting.6}%
\contentsline {lstlisting}{\numberline {7}struct}{12}{lstlisting.7}%
\contentsline {lstlisting}{\numberline {8}trait}{12}{lstlisting.8}%
\contentsline {lstlisting}{\numberline {9}match}{13}{lstlisting.9}%
\contentsline {lstlisting}{\numberline {10}enum}{13}{lstlisting.10}%
\contentsline {lstlisting}{\numberline {11}Veranschaulichung der Monomorphisierung \cite {MonoCodeEx}}{14}{lstlisting.11}%
\contentsline {lstlisting}{\numberline {12}Trait Boundaries \cite {TraitBoundariesEx}}{14}{lstlisting.12}%
\contentsline {lstlisting}{\numberline {13}Operatorenüberladung}{15}{lstlisting.13}%
\contentsline {lstlisting}{\numberline {14}ownership}{16}{lstlisting.14}%
\contentsline {lstlisting}{\numberline {15}borrowing}{17}{lstlisting.15}%
\contentsline {lstlisting}{\numberline {16}Lifetime Veranschaulichung \cite {LifetimeEx}}{18}{lstlisting.16}%
\contentsline {lstlisting}{\numberline {17}Lifetime Beispiele \cite {RustLifetimeEx}}{18}{lstlisting.17}%
\contentsline {lstlisting}{\numberline {18}Überlauf und Ungenauigkeit}{20}{lstlisting.18}%
\contentsline {lstlisting}{\numberline {19}SymPy Präzision}{20}{lstlisting.19}%
\contentsline {lstlisting}{\numberline {20}Benchmark Primitive Typen Stack Ganzzahl}{21}{lstlisting.20}%
\contentsline {lstlisting}{\numberline {21}BTree Ast}{22}{lstlisting.21}%
\contentsline {lstlisting}{\numberline {22}BTree Referenzen}{23}{lstlisting.22}%
\contentsline {lstlisting}{\numberline {23}Datenstruktur in Rust}{25}{lstlisting.23}%
\contentsline {lstlisting}{\numberline {24}eval-Methode 1. Implementierung}{26}{lstlisting.24}%
\contentsline {lstlisting}{\numberline {25}Term 1 Stack und Heap}{27}{lstlisting.25}%
\contentsline {lstlisting}{\numberline {26}Term 2 Stack und Heap}{28}{lstlisting.26}%
\contentsline {lstlisting}{\numberline {27}Enum Token}{30}{lstlisting.27}%
\contentsline {lstlisting}{\numberline {28}trait NumberType 1. Iteration}{32}{lstlisting.28}%
\contentsline {lstlisting}{\numberline {29}Ast Operatorenüberladung}{32}{lstlisting.29}%
\contentsline {lstlisting}{\numberline {30}Operatenüberladung für Addition}{33}{lstlisting.30}%
\contentsline {lstlisting}{\numberline {31}Defintion EvalFn}{35}{lstlisting.31}%
\contentsline {lstlisting}{\numberline {32}Erweiterung pub fn eval}{36}{lstlisting.32}%
\contentsline {lstlisting}{\numberline {33}EvalFn nach expand}{38}{lstlisting.33}%
\contentsline {lstlisting}{\numberline {34}Mögliche Lösungen für Rückgabewerte}{39}{lstlisting.34}%
\contentsline {lstlisting}{\numberline {35}PrimNum vs. PrecisionNum}{43}{lstlisting.35}%
