\documentclass[11pt,a4paper, ngerman]{article}

\usepackage[margin=2.75cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{hologo}
\usepackage{amsmath}
\usepackage{babelbib}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsfonts}
\usepackage{qtree}
\usepackage{makecell}
\definecolor{GrayCodeBlock}{RGB}{245,245,245}
\definecolor{BlackText}{RGB}{10,10,10}
\definecolor{RedTypename}{RGB}{135,58,3}
\definecolor{GreenString}{RGB}{72,125,44}
\definecolor{PurpleKeyword}{RGB}{159,73,183}
\definecolor{GrayComment}{RGB}{70,70,70}
\definecolor{GoldDocumentation}{RGB}{200,185,65}
\lstdefinelanguage{rust}
{
    escapeinside=``,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    frame=single,
    framesep=0pt,
    framerule=0pt,
    framexleftmargin=4pt,
    framexrightmargin=4pt,
    framextopmargin=5pt,
    framexbottommargin=3pt,
    xleftmargin=4pt,
    xrightmargin=4pt,
    backgroundcolor=\color{GrayCodeBlock},
    basicstyle=\ttfamily\color{BlackText},
    keywords={
        true,false,
        unsafe,async,await,move,
        use,pub,crate,super,self,mod,
        struct,enum,fn,const,static,let,mut,ref,type,impl,dyn,trait,where,as,
        break,continue,if,else,while,for,loop,match,return,yield,in
    },
    keywordstyle=\color{PurpleKeyword},
    ndkeywords={
        bool,u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,char,str,
        Self,Option,Some,None,Result,Ok,Err,String,Box,Vec,Rc,Arc,Cell,RefCell,HashMap,BTreeMap,
        macro_rules
    },
    ndkeywordstyle=\color{RedTypename},
    comment=[l][\color{GrayComment}\slshape]{//},
    morecomment=[s][\color{GrayComment}\slshape]{/*}{*/},
    morecomment=[l][\color{GoldDocumentation}\slshape]{///},
    morecomment=[s][\color{GoldDocumentation}\slshape]{/*!}{*/},
    morecomment=[l][\color{GoldDocumentation}\slshape]{//!},
    morecomment=[s][\color{RedTypename}]{\#![}{]},
    morecomment=[s][\color{RedTypename}]{\#[}{]},
    stringstyle=\color{GreenString},
    string=[b]"
}

\lstset{literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Codebeispiel}
\renewcommand{\lstlistlistingname}{Verzeichnis der Codebeispiele}

\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

\pagestyle{fancy}
\fancyhf{}
\lhead{\leftmark}
\rhead{\thepage}
\setlength{\headheight}{0.5cm}

\begin{document}

\title{
    \includegraphics[width=5cm]{logo_fernuni_hagen.png}\\
    \ \\
    Fakultät für Mathematik und Informatik\\
    Bachelor of Science Informatik\\
    \ \\
    Bachelorarbeit\\
    \ \\
    \textbf{Ein Computeralgebrasystem in Rust}\\
    \ \\
    \includegraphics[width=5cm]{rust-logo-512x512-blk.png}
}
\author{
    \begin{tabular}{ll}
        Verfasser & Bernd Haßfurther \href{mailto:nerglom@posteo.de}{<nerglom@posteo.de>}\\
        Matrikel-Nr. & 4372280\\
        Betreuerin & Prof. Dr. Lena Oden\\
        Datum & \today\\
    \end{tabular}
}

\date{}
\clearpage\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Einleitung}
Computeralgebrasysteme - im folgenden abgekürzt durch CAS - nehmen in verschiedenen Bereichen der Wissenschaft eine wichtige Rolle ein. Sie ermöglichen es einerseits mathematische Ausdrücke mit Variablen darzustellen, diese Terme zu verändern und mit diesen zu arbeiten. Andererseits lassen sich wesentlich genauere Berechnungen durchführen, indem z.B. nicht alle Ausdrücke in einem Term ausgewertet werden, wenn es hierdurch zu Ungenauigkeiten kommen kann. Die ``Fachgruppe Computeralgebra'' beschreibt ein solches System wie folgt \cite{FachgruppeDef}:
\begin{quote}
    Die Computeralgebra ist ein Wissenschaftsgebiet, das sich mit Methoden zum Lösen mathematisch formulierter Probleme durch symbolische Algorithmen und deren Umsetzung in Soft- und Hardware beschäftigt. Sie beruht auf der exakten endlichen Darstellung endlicher oder unendlicher mathematischer Objekte und Strukturen und ermöglicht deren symbolische und formelmäßige Behandlung durch eine Maschine. Strukturelles mathematisches Wissen wird dabei sowohl beim Entwurf als auch bei der Verifikation und Aufwandsanalyse der betreffenden Algorithmen verwendet. Die Computeralgebra kann damit wirkungsvoll eingesetzt werden bei der Lösung von mathematisch modellierten Fragestellungen in zum Teil sehr verschiedenen Gebieten der Informatik und Mathematik sowie in den Natur- und Ingenieurwissenschaften.
\end{quote}

Anwendungsbeispiele für ein CAS finden sich in der Physik, Chemie, Sicherheitstechnik, Robotik und vielen anderen Bereichen \cite{FachgruppeEinsatz}. In ``Zum Einfluss von Computeralgebrasystemen auf mathematische Grundfertigkeiten'' werden sowohl Vor- als auch Nachteile bei der Verwendung während der Schulzeit diskutiert \cite[S. 17 ff.]{RN18}. Auch wenn also augenscheinlich die Verwendung eines CAS viele Bereiche entlasten kann, so sollte immer noch das Hintergrundwissen vorhanden sein, was ein CAS überhaupt macht.

In der vorliegenden Arbeit soll ein solches CAS in Ansätzen mit der Programmiersprache Rust entwickelt werden. Es soll untersucht werden, inwieweit das Ownership- und Borrowing-System von Rust bei einem solchen komplexen System bei der Entwicklung unterstützt und wie die Performance zur Laufzeit ausfällt. Das System soll dabei einfach erweiterbar sein. Nicht implementierte mathematische Funktionen sollen einfach integriert werden können und Terme weiter zusammengefasst werden können als die Standardimplentierung erlaubt.

Einen besonderen Stellenwert nimmt SymPy ein, da dieses System einerseits als Open-Source-Projekt verfügbar ist, als auch der Code in Python geschrieben ist und leicht verständlich und erweiterbar ist \cite[S. 1]{SympyPeerJ}. Die Verwendung dieser Bibliothek und die Vorstellung der Programmiersprache Rust während meines Studiums haben mir die Idee gegeben diese Arbeit zu schreiben. Einige Lösungen werden also von SymPy inspiriert sein. Der Code soll dabei natürlich nicht 1-zu-1 in Rust neu geschrieben werden, sondern mit den Möglichkeiten und Einschränkungen von Rust erweitert werden, auch wenn natürlich nur ein Teil des Umfangs von SymPy in dieser Arbeit abgebildet werden kann.

Die Entwicklung von und mit Rust wird immer relevanter. So wird Beispielsweise die Entwicklung für den Linux-Kernel immer weiter vorangetrieben \cite{RustLinux}. Auch für die Entwicklung unter Android \cite{GoogleExample} und Windows \cite{WindowsRust} stehen erste Bestrebungen bereit. Erst letztes Jahr erschienen mit der ``Edition 2021'' \cite{RustEditon2021} neue Features. Für die nächste Version ``Edition 2024'' gibt es ebenfalls bereits eine Roadmap \cite{RustEditon2024}.

Größere Projekte des wissenschaftlichen Bereichs, in denen Rust explizit verwendet wird, lassen sich leider nicht finden. Dafür gibt es unabhängige Pakete, die einzelne Gebiete der wissenschaftlichen Programmierung abdecken \cite{RustEx1} \cite{RustEx2} \cite{RustEx3}. Vereinzelt können Beiträge gefunden werden, die das Thema aufgreifen, aber auch zumeist auf den schweren Einstieg hinweisen \cite{RustUse1} \cite{RustUse2} \cite{RustUse3}. Dies soll in der nächsten Version von Rust verbessert werden \cite{RustEditon2024Specific}.

\newpage

\section{Grundlagen CAS}
Das folgende Kapitel definiert den Funktionumfangs des entwickelten CAS. Um einen Überblick der Größe der Arbeit zu geben, soll näher auf SymPy eingegangen werden und aufgezeigt werden, welche weiteren Implementierungen möglich wären.

\subsection{Grundregeln und Annahmen}
Bevor überlegt wird, wie der Aufbau des CAS aussieht und welche Typen benötigt werden, müssen noch ein paar Vorüberlegungen gemacht werden, welche Grundregeln und Annahmen im System gelten sollen. Ein Teil dieser Regeln stammt aus ``SymbolicC++'' \cite[S. 2]{Tan2000} und ``Algorithms for Computer Algebra'' \cite[S. 23 ff.]{Geddes2007}, andere wiederum sind als Einschränkung oder zur besseren Verständlichkeit im Rahmen dieser Arbeit hinzugefügt worden. Es sollen folgende Zahlenräume betrachtet werden:
\begin{itemize}
    \item $\mathbb{N}$ die Menge der natürlichen Zahlen mit 0, $\{0, 1, 2, 3...\}$
    \item $\mathbb{Z}$ die Menge der ganzen Zahlen, $\{...-3, -2, -1, 0, 1, 2, 3...\}$
    \item $\mathbb{Q}$ die Menge der rationalen Zahlen, $\{...-\frac{2}{1}, -\frac{1}{2}, -\frac{1}{1} 0, \frac{1}{1}, \frac{1}{2}, \frac{2}{1}...\}$
    \item $\mathbb{R}$ die Menge der reellen Zahlen, z.B. $\sqrt{2}$ oder $\pi$
\end{itemize}

Der komplexe Zahlenbereich  $\mathbb{C}$ wird im Rahmen dieser Arbeit nicht betrachtet.

Um insgesamt weniger Bedingungen für mathematische Operationen zu haben, ist geplant folgende Vereinfachungen und Bedingungen anzunehmen. so müssen alle Implementierungen nur die Operationen Addieren und Multiplizieren berücksichtigen.
\begin{itemize}
    \item Jede Substraktion ist im Grunde eine Addition. Für Zahlen bedeudet dies $5-3 = 5+(-3)$ und für Symbole bzw. Terme anderer Art $a-b = a+(-1 * b)$. Eine Besonderheit sollen Terme der Art $1-(a+b+1)$ darstellen, diese sollen zu $1+(-1*a)+(-1*b)+(-1)$ umgeformt werden und nicht zu $1+(-1*(a+b+1))$
    \item Bei Divisionen werden Zahlen zu rationalen Zahlen, also $2/3 = \frac{2}{3}$ und $-(2/3) = \frac{-2}{3}$. Symbole und Terme werden zu einer Multiplikation vereinfacht, also $a/b = b^{(-1)} * a$ und $(a*b*c)/(d+1) = (d+1)^{-1} * (a*b*c)$
    \item Das Kommutativgesetz soll beachtet werden: $x+y = y+x$ also auch $2*(x+y) + (y+x)*2 = 4*(x+y)$
    \item Das Assoziativgesetz soll beachtet werden: $a+(b+c) = (a+b)+c = a+b+c$
    \item Das Distributivgesetz soll beachtet werden: $a*(x+y) = a*x + a*y$
\end{itemize}

\subsection{Funktionsumfang}
Da wie bereits in der Einleitung gezeigt ein CAS sowohl einen sehr breiten Umfang als auch spezialisiert sein kann, muss noch definiert werden, welche Möglichkeiten das in dieser Arbeit entwickelte System besitzt. Konkret soll veranschaulicht werden, welche Operationen erlaubt sein sollen und welche Art von Termen verarbeitet werden können:
\begin{itemize}
    \item Addition von Zahlen (Ganzzahlen, Fließkommazahlen, rationalen Zahlen), z.B. $1+2.1 = 3.1$ oder $\frac{1}{3} + \frac{1}{3} = \frac{2}{3}$
    \item Addition von Symbolen und Termen, z.B. $x+y = x+y$ oder $x+(2*y)+2+(2*y)+x = 2*x+4*y+2$
    \item Multiplikation von Zahlen (Ganzzahlen, Fließkommazahlen, rationalen Zahlen), z.B. $1*2.1 = 2.1$
    \item Multiplikation von Symbolen und Termen, z.B. $x*y*x = x^2*y$
    \item Auswertung von Potenzen die Zahlen, Symbolen und Terme in Basis oder Exponent haben. Dabei sollen Potenzregeln in Hinblick auf Genauigkeit des Ergebnisses ausgeführt werden, z.B. $x^a*x^b=x^{(a+b)}$ oder $x^a*y^a = (x*y)^a$
    \item Auswertung von Funktionen, die dynamisch hinzugefügt werden können. Funktionen die dem CAS nicht bekannt sind, tauchen weiterhin in Termen auf, werden aber nicht ausgewertet, z.B. $sin(x)$ oder $sqrt(x)$
    \item Auswertung von Konstanten falls bekannt und gewollt
    \item Die Ausführungsreihenfolge in Termen lautet: Konstanten und Variablen $\rightarrow$ Funktion $\rightarrow$ Potenz $\rightarrow$ Multiplikation $\rightarrow$ Addition
\end{itemize}

Darüberhinaus sollen Terme soweit wie möglich mit bereits bestehenden Sprachmitteln erweitert und verglichen werden können. Hierzu werden einige Operatorüberladungen implementiert. Bei der Auswertung der Terme soll die Möglichkeit bestehen eventuell ungenaue numerische Ergebnisse zu berechnen. Funktionen und Konstanten sollen später einfach hinzugefügt werden können.

\subsection{Überblick SymPy}
Das SymPy Projekt beschreibt sich selbst als eine Python-Bibliothek für symbolische Mathematik, die das Ziel hat, ein CAS mit ``vollen Funktionsumfang'' zu werden \cite{SymPyAbout}. Im Gegensatz zu dem hier begrenzten System beherrscht SymPy z.B. das Handling von Matrizen \cite[S. 11]{SympyPeerJ} oder auch physikalische Berechnungen \cite[S. 14 ff.]{SympyPeerJ}. Darüberhinaus können auch 2D- und 3D-Grafiken erstellt werden \cite{SymPyPlot} uvm. \cite[S. 4 ff.]{SympyPeerJ}. Das Projekt existiert seit mindestens 2007 \cite{SymPyFirstCommit} und wird seither stetig weiterentwickelt.

Verwendung findet SymPy dabei in anderen Projekten die Teils wiederum spezifisch sind, z.B. ``ChemPy'' \cite{ChemPy} oder mehrere Abhängigkeiten vereinen, z.B. ``sagemath'' \cite {Sagemath}.

\newpage

\section{Vorstellung der Programmiersprache Rust}
In diesem Kapitel sollen die Grundlagen von Rust erläutert werden. Dabei sollen sowohl die Syntax als auch die grundlegenden Konzepte der Sprache und deren Vorteile vermittelt werden.

\subsection{Einführendes Beispiel: Ownership und Borrowing}
Bevor Rust vorgestellt wird und die genauen Regeln des Ownership und Borrowing erläutert werden, soll das Prinzip anhand eines Beispiels verdeutlicht werden. Hierzu wird ein \codeword{struct} - vergleichbar mit Klassen - angelegt, welches z.B. eine große Matrix beinhaltet, die verarbeitet werden soll.

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: struct}]
    struct LargeMatrix {
        matrix: Vec<i32>,
    }
\end{lstlisting}

 Im ersten Beispiel wird eine Funktion erstellt, die das Ownership der Matrix übernimmt und nach der Verarbeitung den Speicherplatz freigibt. Dies geschieht automatisch, da der Gültigkeitsbereich der Variable \codeword{matrix_fn} verlassen wird \cite{RustOwnershipFreed}. In diesem Kontext bedeutet Ownership, dass der Wert vom Hauptprogramm in die Funktion verschoben wird und die neue Variable \codeword{matrix_fn} das alleinige Recht besitzt diesen Wert zu nutzen \cite{RustMovingTerm}. Das Programm lässt sich so nicht kompilieren. Die zweite Ausgabe schlägt dabei fehl, da beim Aufruf der Funktion der Wert in die Funktion verschoben und freigegeben wurde, der Zugriff auf den entsprechenden Speicherbereich im Hauptprogramm wäre undefiniert.

 \begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Ownership abgeben}]
    fn take_ownership(matrix_fn: LargeMatrix) {
        // ...
    }

    let matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_ownership(matrix);
    println!("{:?}", matrix); // <- Fehler
\end{lstlisting}

Die zweite Funktion gibt das Ownership der Matrix wieder zurück, der Wert wird also wieder zurückgeschoben und kann nach dem Funktionsaufruf weiter verwendet werden. Dies geschieht aber nur, wenn der Variablen im Hauptprogramm der Rückgabewert zugewiesen wird. Hierzu muss die Variable \codeword{matrix} explizit als veränderbar mit dem Schlüsselwort \codeword{mut} definiert werden Ein Nachteil dieser Methode ist, dass nicht klar ist, ob es sich um die originale Matrix handelt, oder um eine neu initialisierte Matrix.

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Ownership zurückgeben}]
    fn give_back_ownership(matrix_fn: LargeMatrix) -> LargeMatrix {
        // ...
        // Originale Matrix zurückgeben
        matrix_fn
        // Oder neue Matrix zurückgeben
        // LargeMatrix { matrix: vec![] }
    }

    let mut matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    matrix = give_back_ownership(matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Im nächsten Beispiel erhält die Funktion nur eine Referenz auf die Matrix, gekennzeichnet durch das \codeword{&}-Zeichen. In Rust wird dieses Prinzip als ``Borrowing'' bezeichnet \cite{RustBorrowing}. Wie bereits im ersten Beispiel wird beim Verlassen der Funktion der Speicherplatz der Variablen freigegeben, diesmal handelt es sich aber nur um den Zeiger und nicht um die eigentlichen Daten. Eine Verwendung nach dem Funktionsaufruf ist daher weiterhin möglich.

Da Variablen in Rust standardmäßig unveränderbar sind, ist ebenso sichergestellt, dass die Matrix in der Funktion nicht verändert worden ist. 

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Unveränderliche Referenz}]
    fn take_reference(matrix_ref: &LargeMatrix) {
        // ...
    }

    let matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_reference(&matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Im letzten Beispiel soll nun durch die Verwendung des \codeword{mut}-Schlüsselworts ermöglicht werden, die Daten der originalen Matrix zu verändern. Ansonsten gibt es keine Änderung zum vorherigen Beispiel, beim Verlassen der Funktion wird ebenfalls wieder nur der Zeiger freigegeben.

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Veränderliche Referenz}]
    fn take_mutable_reference(matrix_ref: &mut LargeMatrix) {
        matrix_ref.matrix[0] = 0;
        // ...
    }

    let mut matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_mutable_reference(&mut matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Natürlich können die beiden letzten Funktionen auch einen Rückgabewert besitzen, der unabhängig von der übergebenen Matrix ist. Eine besondere Stärke sind die Regeln, die für das Borrowing gelten. So ist z.B. zu jeder Zeit nur eine veränderbare Referenz auf eine Variable erlaubt, es ist daher leicht nachvollziehbar welcher Programmabschnitt die Daten tatsächlich verändern kann. Race-Conditions in nebenläufigen Anwendungen sind somit ausgeschlossen. Rust bietet für solche Einsatzzwecke Messge Passing \cite{K1727} und threadsichere Referenzzähler \cite{ArcSrc} an. Die Regeln zu Ownership und Borrowing werden noch genauer vorgestellt.

\label{sec:kap2d2}
\subsection{Was ist Rust und warum sollte es verwendet werden}
Rust ist eine statisch typisierte Programmiersprache, welche vor allem mit den Eigenschaften Performance, Verlässlichkeit und Produktivität eine Alternative zu anderen Sprachen anbieten soll \cite{RustPromises}. Version 1.0 wurde 2015 veröffentlich, seitdem gibt es mit der ``Rust 2018 Edition'' und ``Rust 2021 Edition'' eine stetige Weiterentwicklung \cite{RustEditions}.

Die Performance begründet sich durch zwei wesentliche Aspekte. So werden alle Regeln die das Ownership und das Borrowing betreffen bereits zur Compilezeit durchgeführt. Ein zusätzlicher Overhead zur Laufzeit des Programms wird so vermieden. Der andere Aspkekt ist die Implementierung von Featurs in Rust. So wird beispielsweise Monomorphisierung zur Compilezeit von Generics eingesetzt (vgl. \cite[S. 196 ff.]{SK19}). Für jeden implementierten Typen des Generics gibt es somit eine eigene Implementierung im Compilat. Hierdurch entfallen Typechecks wie sie z.B. in Java möglich sein können \cite{JavaGenerics}.

Die Verlässlichkeit beruht ebenfalls auf dem Ownership- und Borrowing-System. Hierdurch ist zu jeder Zeit klar, welche Variablen welche Daten enthalten. Ein unbeabsichtigtes Verändern der Daten oder Dangling References werden ebenfalls bereits zur Compilezeit ausgeschlossen, dieses Prinzip funktioniert ebenfalls in nebenläufigen Anwendungen. Zudem stellt Rust sicher, dass man nicht außerhalb eines Puffers lesen oder schreiben kann, dies kann aber unter Umständen zu einem Programmabbruch führen. Das spezielle \codeword{Option} \codeword{enum} bietet eine fehlerunanfällige Variante des \codeword{NULL}-Werts, das in Rust nicht existiert.

Um die Produktivität zu unterstützen bieten die beiden Tools \codeword{rustup} und \codeword{cargo} alles Notwendige um den kompletten Entwicklungsprozess eines Rust-Programms zu erfüllen. Dies betrifft z.B. konkret eine Abhängigkeitsverwaltung, die Erstellung von Dokumentationen und das Ausführen von Tests und Benchmarks.

Wo nötig setzt Rust auf etablierte Lösungen, so wird LLVM genutzt um ausführbare Programme zu erzeugen (vgl. \cite{RustcCodegen2} und \cite{RustcCodegen}).

\subsection{Grundlegendes}
\paragraph{Expression und Statements} Rust unterscheided bei Code-Anweisungen zwischen Statements und Expressions. Statements führen lediglich einen Codeblock aus, während Expressions stets einen Rückgabewert besitzen. Nahezu alle Sprachelemente in Rust sind als Expression implementiert (vgl. \cite[S. 122 ff.]{BO18}).

\begin{lstlisting}[language=rust, caption={Expression Einführendes Beispiel:}]
    let test_var = if bedingung_1 { false } else { true };
\end{lstlisting}

\paragraph{struct} Um eigene Datentypen zu definieren, werden \codeword{struct}s verwendet. Die Deklaration eines \codeword{struct} gibt nur Felder und Feldtypen an. Methoden und Funktionen werden erst nach der Deklaration hinzugefügt, dabei sind mehrere Implementierungsblöcke möglich. Die Implementierungen können Methoden inkl. einer Referenz auf die aktuelle Instanz oder Funktionen ohne entsprechende Referenz enthalten.

Dabei sollen \codeword{struct}s den Vorteil der Übersichtlichkeit und dieselbe Syntax wie \codeword{enum}s bieten (vgl. \cite[S. 91]{BO18}). Klassen gibt es in Rust nicht.

Das folgende Beispiel deklariert ein \codeword{struct} mit einem Feld. Anschließend wird ein Implementierungsblock angegeben, der jeweils eine Funktion und eine Methode enthält.

\begin{lstlisting}[language=rust, caption={struct}]
    struct MyStruct {
        my_field: i32,
    }

    impl MyStruct {
        fn new() -> MyStruct {
            MyStruct {
                my_field: 5,
            }
        }

        fn do_smth(&self) {}
    }
\end{lstlisting}
\paragraph{trait} In Rust gibt es weder Vererbung durch \codeword{struct}s, noch klassiche Interfaces. Mit \codeword{trait}s kann aber ein ähnliches Verhalten nachgebildet werden. Dabei findet bei der Definition des \codeword{trait} die Deklarierung von Methoden und Funktionen statt. Anschließend können \codeword{struct}s und \codeword{enum}s ein oder mehrere \codeword{trait}s implementieren. Der Traitname wird schlussendlich z.B. in der Parameterdeklaration von Funktionen verwendet.

Für das bereits bestehende \codeword{struct} soll ein \codeword{trait} erstellt und implementiert werden.

\begin{lstlisting}[language=rust, caption={trait}]
    trait MyTrait {
        fn trait_method(&mut self) -> bool;
    }

    impl MyTrait for MyStruct {
        fn trait_method(&mut self) -> bool {
            true
        }
    }
\end{lstlisting}
\paragraph{match} Als Alternative zur \codeword{switch}-Anweisung bietet Rust \codeword{match}. Im Gegensatz zu anderen Sprachen muss bei \codeword{match} jeder mögliche Wert einer Variablen geprüft werden. Durch einen Variablennamen als letzter zu prüfender Wert wird dieser verallgemeinert. Alternativ kann der Wert unberücksichtigt gelassen werden.

Bei der Auswertung der Variablen ist es zudem erlaubt mehrere Werte gleichzeitig anzugeben. Da \codeword{match} ebenfalls als Expression umgesetzt ist, kann ein Rückgabewert wieder einer Variablen zugeordnet werden. Je nach Wert können verschiedene Aktionen ausgeführt werden, die ursprüngliche Variable geändert werden und ebenfalls ein Rückgabewert definiert werden.

\begin{lstlisting}[language=rust, caption={match}]
    let mut var = 19;

    let match_var = match var {
        1 => {
            var = 5;
            String::from("klein")
        }
        2..=10 => String::from("bis 10"),
        11 | 13 | 17 => String::from("Primzahl"),
        i => i.to_string(),
        // _ => String::from("Nichts"),
    };
\end{lstlisting}

\subsection{Enums}
Der Aufzählungstyp \codeword{enum} spielt in Rust eine wichtige Rolle. So wird z.B. mit dem \codeword{enum} \codeword{Result} das Error-Handling in Rust ermöglicht. Weiterhin gibt es mit dem \codeword{Option} \codeword{enum} wie bereits erwähnt eine Alternative um fehlende \codeword{NULL}-Werte in Rust zu darzustellen.

Jede Ausprägung eines \codeword{enum} kann verschiedene Werte enthalten. Wie bereits \codeword{struct}s können Implementierungsblöcke definiert und Traits implementiert werden. Mit dem bereits vorgestellten \codeword{match} kann geprüft werden, welche Ausprägung das \codeword{enum} hat. Alternativ funktioniert dies auch mit der \codeword{if let}-Anweisung, die es erlaubt nur auf eine Ausprägung zu überprüfen.

In diesem Beispiel wird ein \codeword{enum} mit verschiedenen Werten definiert, die dann über eine \codeword{match}-Anweisung konkret abgefragt werden können. Zudem gibt es wieder einen Implementierungsblock für Fuktionen und Methoden und es wird ein \codeword{trait} implementiert. Die Syntax ist dabei identisch wie bereits bei \codeword{structs}.

\begin{lstlisting}[language=rust, caption={enum}]
    enum MyEnum {
        Entry1 { c: i32, m: i32, y: i32, k: i32 }, // Anonymes struct
        Entry2(i32, i32, i32), // 3 unbenannte Werte
        Entry3, // ohne Daten
    }

    let x = MyEnum::Entry2(42, 42, 42);
    match x {
        MyEnum::Entry2(v1, v2, v3) => { ... },
        _ => { ... }
    };

    impl MyEnum { ... }
    impl MyTrait for MyEnum { ... }
\end{lstlisting}

\subsection{Generics}
Rust bietet ebenfalls generische Typparameter an. Diese können bei \codeword{struct}, \codeword{enum}, \codeword{trait} und Funktionen verwendet werden. Um eine hohe Performance zu gewährleisten, wird Monomorphisierung zur Compilezeit eingesetzt (vgl. \cite[S. 196 ff.]{SK19}). Dies bedeutet, dass z.B. eine entsprechende Funktion speziell für die verwendeten Typen implementiert wird.

Dies wird exemplarisch für das bestehende \codeword{Option} \codeword{enum} veranschaulicht, welches im fertigen Programm zwei mal mit unterschiedlichen Typen existiert.

\begin{lstlisting}[language=rust, caption={Monomorphisierung Veranschaulichung \cite{MonoCodeEx}}]
    // enum im Quellcode
    enum Option<T> {
        Some(T),
        None,
    }

    let integer = Some(5);
    let float = Some(5.0);
    
    // enum nach Monomorphisierung
    enum Option_i32 {
        Some(i32), None,
    }
    enum Option_f64 {
        Some(f64), None,
    }
    fn main() {
        let integer = Option_i32::Some(5);
        let float = Option_f64::Some(5.0);
    }
\end{lstlisting}

Im Zusammenspiel mit \codeword{traits} kann ein entsprechender Typparameter begrenzt werden. Ein Nachteil der Monomorphie ist, dass ein Typparameter immer nur von einem konkreten Typ ersetzt werden kann. Eine Lösung hierfür bieten \codeword{trait objects}.

Im folgenden Beispiel dazu werden ein \codeword{trait} und zwei \codeword{structs} definiert, die ein \codeword{trait} implementieren. Das \codeword{ScreenTraitObject} kann im Vektor \codeword{components} beide Structs unabhängig voneinander vorhalten, da \codeword{trait objects} verwendet werden. \codeword{ScreenGeneric} benutzt allerdings nur einen einfachen Generic-Parameter für den Vektor, sodass tatsächlich nur eine konkrete Implementierung von \codeword{Draw} hinzugefügt werden kann.

Durch den \codeword{Box}-Typ werden die Werte auf dem Heap abgelegt, da nicht von vornherein klar ist, wie viel Speicher auf dem Stack benötigt wird.

\begin{lstlisting}[language=rust, caption={Trait Boundaries \cite{TraitBoundariesEx}}]
    trait Draw {}

    struct Button {}
    struct SelectBox {}

    impl Draw for Button {}
    impl Draw for SelectBox {}

    struct ScreenTraitObject {
        components: Vec<Box<dyn Draw>>,
    }
    // Bevorzugt, wenn nur wenige Typparemeter und/oder Einschränkungen
    struct ScreenGeneric<T: Draw> {
        components: Vec<T>,
    }
    // Oder falls mehrere Typparemeter und/oder Einschränkungen
    struct ScreenGeneric2<T, U>
    where
        T: Draw + Trait2 + Trait3,
        U: Trait4
    {}

    ScreenTraitObject {
        components: vec![
            Box::new(Button {}),
            Box::new(SelectBox {}),
        ],
    };

    ScreenGeneric {
        components: vec![
            Button {},
            SelectBox {}, // Fehler, da SelectBox != Button
        ],
    };
\end{lstlisting}

\subsection{Operatorenüberladung} In Rust können Operatoren überladen werden und somit für eigene als auch bestehende Typen implementiert und erweitert werden \cite{OperatorOverloading} \cite[S. 246 ff.]{BO18}. Diese Funktionlität kann im CAS dazu genutzt werden, um z.B. einen bestehenden Term ohne Funktionsaufruf zu verändern. Stattdessen können gewohnte Sprachmittel verwendet werden. Auch ist es möglich die Prüfung auf Gleichheit mit einem anderen Datentyp zu implementieren.

Im Beispiel kann das erstellte \codeword{enum} mit sich selbst addiert und mit dem primitiven Datentyp \codeword{i32} verglichen werden. Dabei werden die bereits existierenden Operatoren ``+'' und ``=='' verwendet.

\begin{lstlisting}[language=rust, caption={Operatorenüberladung}]
    enum Number {
        Int(i32),
        Float(f64),
    }

    impl std::ops::Add<Number> for Number {
        type Output = Number;

        fn add(self, rhs: Number) -> Number {
            match (self, rhs) {
                (Number::Int(v1), Number::Int(v2)) => Number::Int(v1 + v2),
                // Weitere Implementierung
            }
        }
    }

    let n1 = Number::Int(1);
    let n2 = Number::Int(2);
    let n3 = n1 + n2;

    impl PartialEq<i32> for Number {
        fn eq(&self, other: &i32) -> bool {
            match self {
                Number::Int(v) => v == other,
                _ => false,
            }
        }
    }

    if n3 == 3 { ... }
\end{lstlisting}

\subsection{Ownership, Borrowing und Lifetimes}
Im folgenden sollen die Konzepte Ownership, Borrowing und Lifetimes vorgestellt werden, diese tragen wesentlich zur erwähnten Speichersicherheit bei. Der Compiler beachtet dabei die folgenden Regeln \cite{Rules1} \cite{Rules2}.

\begin{itemize}
    \item Jeder Wert ist einer Variablen zugewiesen, dem \codeword{Owner}
    \item Jeder Wert kann nur einen \codeword{Owner} besitzen
    \item Verlässt der \codeword{Owner} den Gültigkeitsbereich, wird die Variable ungültig und im Normalfall der Speicherplatz freigegeben
    \item Zu jeder Zeit kann es eine beliebige Anzahl an nicht veränderbaren Referenzen geben oder exakt eine veränderbare Referenz
    \item Referenzen müssen immer gültig (d.h. deklariert sein und der Owner muss mindestens denselben Gültigkeitsbereich wie die Referenz haben) sein
\end{itemize}

Das Ownership-Prinzip deckt dabei bereits die ersten drei Regeln ab. Zu jedem Zeitpunkt kann jeder Wert nur durch eine Variable angesprochen werden. Liegt der Wert auf dem Stack oder wird das \codeword{Copy}-Trait implementiert, wird bei einer Zuweisung der Wert kopiert \cite{CopyTraitOwner}. Liegt der Wert hingegen auf dem Heap, wie z.B. bei einem \codeword{Vector} oder einem \codeword{String} wird das Ownership an die neue Variable übergeben.

\begin{lstlisting}[language=rust, caption={ownership}]
    let mut a = 2;
    let b = a;
    a = 4;
    println!("{}{}", a, b); // Ausgabe: 42

    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s2); // Ok
    println!("{}", s1); // Fehler, Ownership wurde s2 übertragen
\end{lstlisting}

Um nun nicht ständig den Owner der Daten ändern zu müssen z.B. bei einem Funktionsaufruf werden mit dem Borrowing Referenzen erstellt. Hierauf beziehen sich die beiden letzten Regeln. Dabei gilt außerdem, dass es nur veränderbare Referenzen geben kann, wenn der Owner veränderbar ist und falls es eine veränderbare Referenz gibt, kann der Wert auch nur exklusiv durch diese verändert werden. Zur Referenzierung und Dereferenzierung kommen die \codeword{&}- und \codeword{*}-Operatoren zum Einsatz.

\begin{lstlisting}[language=rust, caption={borrowing}]
    // Nicht zulässig, da zwei mutable Referenzen
    let mut a = 5;
    let b = &mut a;
    let c = &mut a;
    *b = 1;

    // Nicht zulässig, da mutable und nicht mutable gemischt
    let mut a = 5;
    let b = &mut a;
    let c = &a;
    let d = &a;
    *b = 1;

    // Zulässig, da nur lesende Referenzen
    let a = 5;
    let b = &a;
    let c = &a;

    fn append_string(string1: &mut String, string2: &String) {
        string1.push_str(string2);
    } // Nur Referenzen verlassen den Gültigkeitsbereich, nicht die Owner!

    let mut s1 = String::from("Fern");
    let s2 = String::from("Uni");
    append_string(&mut s1, &s2);
    println!("{}", s1); // Ausgabe: FernUni
\end{lstlisting}

Schlussendlich verhindern Lifetimes, dass die Referenzen für das Borrowing ungültig werden, und die Variable - und somit der Wert - vor den Referenzen freigegeben wird. Die Illustrierung der Lifetimes enstpricht dabei den Codeblöcken, in denen die Referenzen definiert sind. Die inneren Lifetimes im Beispiel könnten dabei aber auch Funktionsaufrufe sein. Das erste Beispiel ist ungültig, da die Lifetime des Wertes kleiner ist, als die Referenz, die darauf zeigen soll.

Das zweite Beispiel ist dagegen gültig, da der eigentliche Wert erst nach der Referenz freigegeben wird.

\begin{lstlisting}[language=rust, caption={Lifetime Veranschaulichung \cite{LifetimeEx}}]
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+

    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
\end{lstlisting}

In den meisten Fällen kann der Compiler die Lifetimes von Variablen und Referenzen selbst bestimmen. Eine explizite Deklarierung der Lifetimes ist nötig, wenn beispielsweise eine Funktion mehr als eine Referenz entgegennimmt und auch wieder zurückgibt. Dies soll an einem Beispiel verdeutlicht werden. Die Lifetimedeklarierung \codeword{'a} gibt an, dass sowohl die beiden Auswahlmöglichkeiten als auch der Rückgabewert diesselbe Lifetime besitzen müssen. Während dies bei der ersten Zuweisung erfüllt ist, wird eine Auswahlmöglichkeit bei der zweiten Zuweisung erst in einer inneren Lifetime deklariert, dies stimmt dann aber entsprechend nicht mit dem Rückgabewert überein.

\begin{lstlisting}[language=rust, caption={Lifetime Beispiele \cite{RustLifetimeEx}}]
    fn main() {
        // Funktioniert, da Werte dieselbe Lifetime wie Rückgabewert haben
        let mult1 = 1;
        let mult2 = 2;
        let multiplikator = {
            let zaehler: i32 = 3;
            multiplikator_waehlen(&mult1, &mult2, &zaehler)
        };

        // Funktioniert nicht, da mult2 vor multiplikator freigegeben wird
        let mult1 = 1;
        let multiplikator = {
            let mult2 = 2;
            let zaehler: i32 = 3;
            multiplikator_waehlen(&mult1, &mult2, &zaehler)
        };
    }

    fn multiplikator_waehlen<'a, 'b>(
        mult1: &'a i32,
        mult2: &'a i32,
        decision_maker: &'b i32,
    ) -> &'a i32 {
        if *decision_maker < 5 {
            mult1
        } else {
            mult2
        }
    }
\end{lstlisting}

\newpage

\section{Implementierung des CAS}
Das folgende Kapitel stellt die Implementierung des CAS in den Vordergrund. Dabei sollen auch Überlegungen zu früh auftretenden Problemen aufgezeigt werden.

\subsection{Überlauf und Ungenauigkeit}
Ein bereits zu Beginn auftretendes Problem für das CAS ist der Umang von Ganzzahlüberläufen und die Ungenaugikeiten der Rechnung mit Fließkommazahlen \cite{IEEE754}. So gibt das folgende Programm in Rust einen falschen Wert für die Addition aus und bricht anschließend ab.

\begin{lstlisting}[language=rust, caption={Überlauf und Ungenauigkeit}]
    let f1 = 0.1;
    let f2 = 0.2;
    println!("{}", f1 + f2);

    let mut x = i32::MAX;
    x += 1;
    println!("{}", x);

    // Ausgabe
    0.30000000000000004
    thread main panicked...
\end{lstlisting}

Ein Blick zu SymPy zeigt, dass bereits hier Lösungen direkt aus Python verwendet werden können, die in Rust nicht existieren. So besitzen Ganzzahltypen bereits eine beliebige Präzision \cite{PythonDocuIntPrecision}. Für Fließkommazahlen ist die Klasse \codeword{Float} implementiert, die eine ungebrenzte Genauigkeit erlaubt. Dabei kann mit dem zweiten Parameter die eigentliche Präzision bestimmt werden. Es wird darüberhinaus angeraten den eigentlichen Wert als String zu übergeben, da der native float-Typ in Python bereits eine Ungenauigkeit hervorrufen kann \cite{SymPyFloat}.

\begin{lstlisting}[language=Python, caption={SymPy Präzision}]
    x = 12345678901234567890...
    print(type(x))
    // <class int>

    print(sympy.Float('0.1', 100) + sympy.Float('0.2', 100))
    // 0.300000000000000000000000000000000000000000000...

    print(float(0.1) + float(0.2))
    // 0.30000000000000004
\end{lstlisting}

In ``Modern Computer Algebra'' \cite[S. 29 ff.]{Gathen2013} und ``Computer Algebra - Concepts and Techniques'' \cite[S. 81 ff.]{Lamagna2019} sind theoretische Implementierungen für Ganzzahlwerte angegeben. Hiervon könnten wir in dieser Arbeit natürlich gebrauch machen und diese Typen selbst implementieren und für Fließkommazahlen erweitern, da Rust diese Typen leider nicht selbst anbietet. Allerdings existieren bereits die beiden Crates (Abhängigkeiten im Rust-Ökosystem) ``num'' \cite{CrateNum} und ``bigdecimal'' \cite{CrateBigdecimal}, die Typen mit ungebrenzter Präszision anbieten.

Folgend soll die Performance zwischen den primitiven Typen auf dem Stack, den primitiven Typen auf dem Heap und den Crates verglichen werden. Wie zu erwarten ist die Speicherung auf dem Stack am effizientesten, der Zugriff auf dem Heap kostet Zeit. Der zusätzliche Zeitverlust bei den Crates lässt sich zum einen dadurch erklären, dass immer ein Überlauf geprüft werden muss um den Wert richtig zu verarbeiten, andererseits verwendet der Typ \codeword{BigInt} einen Vektor. Wie in \hyperref[sec:kap2d2]{Kapitel 2.2} bereits erwähnt, wird bei einem Zugriff zusätzlich geprüft, ob der Index gültig ist, was ebenfalls Zeit kostet.

Im Benchmark werden Zahlen von 10 bis 9999 durchlaufen und in jedem Durchlauf auf das vorherige Ergebnis addiert und danach durch drei geteilt.

\begin{lstlisting}[language=rust, caption={Benchmark Primitive Typen Stack Ganzzahl}]
    let mut x: i64 = 0;
    for i in 10..10000 {
        x += i;
        x /= 3;
    }
    assert_eq!(x, 4999);
\end{lstlisting}

\begin{table}[h!]
    \caption{Ergebnisse Benchmark Rust-Typen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Test} & \textbf{Zeit Median in ns} & \textbf{\makecell{Unterschied min. und max. Laufzeit \\ in ns}} \\
        \hline
        Primitiv int & 18.505 & 396 \\
        \hline
        Primitiv int Heap & 50.293 & 1.683 \\
        \hline
        Primitiv float & 36.975 & 809 \\
        \hline
        Primitiv float Heap & 74.324 & 920 \\
        \hline
        num Crate & 548.640 & 42.989 \\
        \hline
        bigdecimal Crate & 7.447.000 & 474.681 \\
        \hline
    \end{tabular}
\end{table}

Leider ist es mit Rust-Benchmarks noch nicht möglich den Speicherverbrauch zu messen. Allerdings können wir diesen für unsere Beispiele auch selbst gut bestimmen. Hierbei geht es nur um die eigentlichen Werte, mit denen Berechnungen durchgeführt werden.

\paragraph{Primitive Typen Stack} Die Datentypen \codeword{i64} und \codeword{f64} verbrauchen 8 Bytes. Es werden also nie mehr als $8*4=32$ Bytes für die eigentlichen Daten benötigt. Die Variable $x$, die das Ergebnis enthält beansprucht davon 8 Bytes. Der Schleifenparameter $i$ wird ebenfalls als \codeword{i64} (bzw. \codeword{i32} im Falle der Benchmarks mit \codeword{f64}) behandelt durch die Addition mit $x$ (bzw. dem TypeCasting) und verbraucht ebenfalls 8 Bytes. Bei der Addition $x+i$ wird nun wie bereits erwähnt bei einem Funktionsaufruf eine Kopie der Werte erstellt, die den Copy-Trait implementiert haben. Die Typen \codeword{i64} und \codeword{f64} haben diesen implementiert \cite{Rusti64Copy} und somit wird sowohl von $x$ als auch von $i$ zur Addition eine Kopie erzeugt.

\paragraph{Primitive Typen Heap} Der Speicherverbrauch der eigentlich Werte ist wie bei den primitiven Typen auf dem Stack. Davon entfallen aber 8 Bytes auf dem Heap statt auf dem Stack, zur Berechnung müssen die \codeword{Box}-Werte dereferenzieren werden. Zusätzlich befindet sich ein Zeiger auf dem Stack durch \codeword{Box}. Die Größe hiervon hängt von der verwendeten Architektur ab \cite{BoxExmaple}.

\paragraph{num und bigdecimal} Bei dem Datentyp BigInt wird einerseits ein Vorzeichen verwendet, welches 1 Byte verbraucht \cite{EnumSize} als auch der Datentyp BigUint der wiederum einen Vektor mit BigDigit erhält. Das Vorzeichen ist als \codeword{Enum} umgesetzt \cite{BigIntSign}. Schaut man sich diese Definition an, kann dieser Typ zwischen 4 Bytes (u32) und 16 Bytes (i128) verbrauchen. Während des Debuggens auf verschiedenen Systemen wird in diesem Beispiel der Typ u64 angenommen und somit ein Speicherplatz von 8 Bytes benötigt. Mit größer werdenden Zahlen steigt allerdings dieser Verbrauch, da sich der Vektor vergrößert. Auch liegen nicht mehr alle Daten auf dem Stack, sondern alle BigDigits auf dem Heap, was die Zugriffsgeschwindigkeit wieder ebenfalls erhöht.

Der Typ bigdecimal verwendet laut Beschreibung den Typ BigInt und zusätzlich einen 64-Bit-Integer um die Position der Dezimalstelle zu bestimmen \cite{CrateBigdecimalDocs}. Dadurch erhöht sich der Speicherverbrauch also nur unwesentlich.

\paragraph{Entscheidung der verwendeten Typen} Im Rahmen dieser Arbeit ist zumindest eine eigene Implementierung der Typen für beliebige Präzision nicht das Ziel. Genausogut können auch die bereits bestehenden Crates verwendet werden. Da dadurch aber die Performance leidet, wenn auch wahrscheinlich nicht relevant für spätere Beispiele und Tests, ist wiederrum die Implementierung mit primitiven Typen von Vorteil.

Da Rust Generics untersützt wurde die Entscheidung getroffen, das CAS in Teilen mit Generics umzusetzen, sodass beide Kombinationen verwendet werden können. Dabei sollen alle Funktionen des Systems mit den primitiven Typen funktionieren und einige Beispielimplementierungen mit den Crate-Typen gemacht werden. Dies erlaubt einerseits eine spätere Erweiterung der Crate-Typen als auch die Entwicklung der eigenen Typen.

\subsection{Grundlegende Datenstruktur}
Eine erste Idee, wie die Datenstruktur aussehen könnte, war ein einfacher binärer Baum, dessen Knoten die Operanden und die Blätter einzelne Werte sind. Dies entspricht dem abstrakten Syntaxbaum nach dem Parsen. Für den Term $x+1+2$ ergibt sich folgender Baum.

\Tree[.+
        [.+
                [.x ]
                [.1 ]
        ]
        [.2 ]
    ]

In Rust sähe die Implementierung folgendermaßen aus. Die Ausprägung Add benötigt für die Werte immer den Wrapper \codeword{Box} der die Daten auf den Heap speichert. Zur Compilezeit lässt sich die Größe auf dem Stack nicht bestimmen, da nicht bestimmt ist, wie viele Ebenen Add beinhaltet \cite{RustRecursiveTypes}.

\begin{lstlisting}[language=rust, caption={BTree Ast}]
    enum BTree {
        Number(i64),
        Symbol(String),
        Add(Box<BTree>, Box<BTree>),
    }

    let tree = BTree::Add(
        Box::new(BTree::Add(
            Box::new(BTree::Symbol("x".to_owned())),
            Box::new(BTree::Number(1)),
        )),
        Box::new(BTree::Number(2)),
    );
\end{lstlisting}

Bei der direkten Änderung bzw. Zusammenfassung des Baums ergibt sich nun durch das Ownership ein Problem. Man bräuchte auf jeden Knoten und Blatt eine veränderbare Referenz. In unserem Beispiel würden im einfachsten Fall das untere \codeword{BTree::Add} durch \codeword{BTree::Symbol} ersetzt werden und das rechte \codeword{BTree::Number} aktualisiert werden.

Würde versucht werden die Referenzen in einem Vektor zu speichern, ist das zumindest bereits für \codeword{Add} nicht möglich. Da \codeword{Box} das Ownership des Wertes nimmt, kann dazu parallel keine veränderbare Referenz existieren. Dasselbe Problem tritt auf, wenn die Blätter bereits der entsprechende \codeword{Box}-Wert sind, dann würde das Ownership immer noch an \codeword{parent_1} übergeben werden.

\begin{lstlisting}[language=rust, caption={get refs}]
    let mut leave_1 = BTree::Number(1);
    let mut leave_2 = BTree::Number(2);
    let mut parent_1 = BTree::Add(Box::new(leave_1), Box::new(leave_2));

    let mut refs = vec![&mut parent_1, &mut leave_1, &mut leave_2];
    println!("{:?}", refs);
\end{lstlisting}

Hier könnte nun versucht werden das Problem mit Referenzzählern (vgl. \cite{RcSrc} und \cite[S. 293 ff.]{SK19}) zu lösen, die dafür gedacht sind mehrere Referenzen zu erzeugen, die in Kombination mit anderen Strukturen in Rust auch veränderbar sein können (vgl. \cite{CellSrc}, \cite{RefCellSrc} und \cite[S. 299 ff.]{SK19}).

Auch wäre die Nutzung von Rohzeigern in Verbindung mit \codeword{unsafe} möglich, was Code in Rust kennzeichnet, der auf undefinierten Speicherbereich zeigen kann \cite{RustUnsafe}.

Da beide Varianten aber sich entweder auf den Codeumfang und -verständlichkeit auswirken oder der Hauptgrund Rust zu benutzen umgangen wird, soll, wenn möglich auf diese Möglichkeiten verzichtet werden. Damit ausgeschlossen ist aber auch die Möglichkeit den Baum in situ zu verändern

Eine Alternative wäre nur lesende Referenzen zu erzeugen, über diese zu iterieren und dann einen neuen Baum zu erstellen. Wenn aber sowieso alle Werte benötigt werden um diese zusammenfassen zu können, könnten diese auch in in einem Vektor  gespeichert werden. Für die Addition und Multiplikation würde dann der Baum für den Term $myfunc(a, b*c)+1+2+x*y*2^z$ beispielsweise so aussehen:

\Tree[.+-Vektor
        [.func
            [.``myfunc'' ]
            [.Parameter-Vektor
                [.a ]
                [.*-Vektor
                    [.b ]
                    [.c ]
                ]
            ]
        ]
        [.1 ]
        [.2 ]
        [.*-Vektor
            [.x ]
            [.y ]
            [.pow
                [.2 ]
                [.z ]
            ]
        ]
    ]

Werden die Bedingungen und Vereinfachungen noch angewendet, so ergibt sich für den Term $a-(1+b)+3/5$ der Baum:

\Tree[.+
        [.a ]
        [.-1 ]
        [.*
            [.-1 ]
            [.b ]
        ]
        [.Rational
            [.3 ]
            [.5 ]
        ]
    ]

Eine ähnliche Struktur findet sich ebenfalls in ``SymbolicC++'' \cite[S. 284 ff.]{Tan2000}. SymPy verwendet ebenfalls diese Struktur \cite{SymPyTreeStruct}. Da sich dieser Aufbau anscheinend für ein CAS eignet, soll dieser auch in diesem System verwendet werden. Hierrauf bauen alle weiteren Operationen auf, wie z.B. das Zusammenfassen des Terms oder Substitution.

\subsection{Grundtypen des CAS}
In diesem Kapitel soll definiert werden, welche \codeword{structs}, \codeword{traits} oder \codeword{enums} benötigt werden, um das CAS zu erstellen. Darüberhinaus soll grob umrissen werden, welche Implementierungen im weiteren Verlauf sinnvoll sein können und welchen Zweck diese erfüllen.
Es ist noch zu erwähnen, dass hier nicht definiert werden soll, mit welche \codeword{Derive macros} diese Typen erhalten. In Rust ist es üblich \codeword{structs} und \codeword{enums} mit diesen Makros zu erweitern, um z.B. anzugeben, dass der Typ kopiert oder sortiert werden kann. Die Implementierung dieser Funktionalität wird dann teilweise zur Compilezeit vom Makro übernommen.

\label{sec:NumTypes}
\paragraph{enum PrimNum und enum PrecisionNum} Diese beiden \codeword{enums} sollen als Implementierung für den Generic-Parameter im CAS dienen. Ebenso bieten diese den Vorteil, dass später ein allgemeiner Nummern-Typ existiert mit dem gerechnet werden kann, und nicht ständig manuell Type Castings durchgeführt werden müssen. So ist es in Rust nicht möglich eine Addition oder Multiplikation von i32 und f64 durchzuführen. Hierzu muss einer der beiden Werte erst in den anderen manuell überführt werden.

Ein weiterer Vorteil ist, dass direkt eine rationale Ausprägung des \codeword{enum} implementiert werden kann. Auch hier kann der Typ direkt die Rechnung übernehmen. Hierzu werden die Operatoren \codeword{std::ops::Add} und \codeword{std::ops::Mul} für das Enum selbst überladen. Im Hinblick auf die Bedingung, dass eine Subtraktion eine Addition ist, wird ebenso \codeword{std::ops::Mul} für einen Ganzzahlwert mit den Enums überladen. Ebenso kann es von Interesse sein, ob es sich um das neutrale Element der Addition oder Multiplikation handelt um einen Term zu vereinfachen. Für diesen Fall wird der Trait \codeword{PartialEq} für Ganzzahlen überladen, um hier nach Bedarf auch andere Werte zu überprüfen. Eine Alternative wären Methoden, die einen \codeword{bool}-Wert zurückgeben, ob es sich um einen solchen Wert handelt.

In unserer Implementierung wird \codeword{PrimNum} solange wie möglich mit Ganzzahlen und Rationalen Werten arbeiten. Sobald ein Fließkommawert addiert wird, werden die beiden anderen Werte zu einer Fließkommazahl umgewandelt. Dies geht zulasten der Genauigkeit und könnte bei Bedarf so angepasst werden, dass eine rationale Zahl erzeugt wird. Es wäre auch denkbar, Fließkommazahlen und andere numerische Typen nicht standardmäßig zusammenzufassen.

\paragraph{trait NumberType} Dieser Trait soll hauptsächlich als Typparameter oder als Einschränkung für Generics zum Einsatz kommen. Wie bereits erwähnt soll ein Teil des CAS mit verschiedenen Typen durchführbar sein und alle Typen, die diesen Trait implementieren können dann für das CAS genutzt werden. Im konkreten Fall werden dies die beiden \codeword{enums} sein, die gerade erwähnt worden sind. Zudem werden Funktionen als Bedingung definiert um die neutralen Elemente der Addition und der Multiplikation zurückzugeben als auch eine Möglichkeit einen Bruch zu kürzen. Diese müssen dann von den \codeword{enums} implementiert werden.

Außerdem kann dieser Trait bereits weitere Bedingungen aufnehmen wie z.B. dass der implementierende Enum gewisse Operatorenüberladungen haben muss oder auch, dass die Werte vergleichbar und sortierbar sind.

\paragraph{struct Parser} Auch wenn angedacht ist, eine bestehende Bibliothek zur lexikalischen Analyse von Strings einzusetzen, benötigen wir einen Parser, der die generierten Tokens oder die entstehende Datenstruktur in die Struktur des Systems überführt.

\subsection{Datenstruktur in Rust}
Mit dem Wissen über Generics und und den theoretischen Überlegungen zur Datenstruktur, kann diese in Rust folgendermaßen umgesetzt werden:
\begin{lstlisting}[language=rust, caption={Datenstruktur in Rust}]
    pub enum Ast<N> {
        Add(Vec<Ast<N>>),
        Mul(Vec<Ast<N>>),
        Pow(Box<Ast<N>>, Box<Ast<N>>),
        Symbol(String),
        Const(String),
        Func(String, Vec<Ast<N>>),
        Num(N),
    }
\end{lstlisting}

\paragraph{Add und Mul} Diese beiden Ausprägungen besitzen als Wert einen Vektor, der weitere Elemente enthält. So sind diese einfach abrufbar und der Vektor kann gezielt geändert werden, z.B. zum sortieren der Werte oder das Entfernen von unnötigen Elementen (neutrale Elemente der Addition oder Multiplikation).

\paragraph{Pow} Diese Ausprägung besitzt zwei Parameter, Basis und Exponent, die jeweils wieder beliebige Ausdrücke sein können.

\paragraph{Symbol} Ein einfacher String, der einen Variablennamen enthält. Diese sollen später einfach substituiert werden können.

\paragraph{Const} Ein einfacher String, der einen Konstantennamen enthält, auch in UTF-8 möglich, z.B. $\pi$. Eigens hinzugefügte Funktionen können somit prüfen, um welche Konstante es sich handelt und entsprechend eine Vereinfachung implementieren. Es besteht darüberhinaus die Möglichkeit Konstanten als Wert zurückzugeben.

\paragraph{Func} Diese Ausprägung besitzt ebenfalls zwei Parameter, den Namen der Funktion und die übergebenen Parameter als Vektor. Der Name kann somit einfach ausgewertet, die Parameter einfach übergeben werden.

\paragraph{Num} Diese Ausprägung enthält als Wert eine Variante, die das \codeword{trait} \codeword{NumberType} implementiert.

\paragraph{Auswertung des Terms} Eine Hauptfunktionalität, die dieses Enum erhält, ist die Möglichkeit einen Term zusammenzufassen und falls möglich soweit wie möglich in ein numerisches Ergebnis zu überführen. Dabei muss natürlich einerseits die Ausführungsreihenfolge beachtet werden, andererseits soll diese Methode leicht erweiterbar sein.

In unserem System wird die Methode rekursiv implementiert. Eine iterative Lösung wäre ebenfalls möglich, aufgrund des Ownership und Borrowing in Rust aber tatsächlich recht komplex und weniger leserlich und verständlich \cite{RustRecToItAst}.

Bei der entsprechenden Auswertung einer Ausprägung des \codeword{Ast} werden dabei erst alle ``Kindelemente'' ausgewertet. Für die Addition bedeutet dies konkret, dass erst alle Elemente im Vektor ausgewertet werden und danach erst versucht wird zu addieren. Für Potenzen werden entsprechend erst Basis und Exponent ausgewertet.

Eine erste Implementierung hierfür sieht folgendermaßen aus. Die beiden zusätzlichen Parameter \codeword{evaler} und \codeword{hard_eval} werden noch näher in den Kapiteln zu ``\hyperref[sec:kapErRustUndBei]{Erweiterbarkeit in Rust und Beispiele}'' und ``\hyperref[sec:ungenauigkeitenKapitel]{Ungenauigkeiten erlauben}'' näher erläuert.

Bei der Entscheidung, ob das Element direkt bearbeitet wird oder ein neuer \codeword{Ast} zurückgegeben wird, wurde der Definition von SymPy gefolgt, dass der originale Term nicht verändert wird und ein neuer erstellt wird \cite{SymPySubs}.

\begin{quote}
    SymPy expressions are immutable. No function will change them in-place.
\end{quote}

Auch ist hier ersichtlich, dass teilweise die \codeword{clone}-Methode aufgerufen werden muss, da ansonsten ja nur die Referenz \codeword{self} zurückgegeben werden würde. Der \codeword{Copy}-Trait kann für \codeword{Ast} nicht implementiert werden, da bereits Vektoren diesen Trait nicht implementieren.

\begin{lstlisting}[language=rust, caption={eval-Methode 1. Implementierung}]
pub fn eval(
        &self,
        evaler: &EvalFn<N>,
        hard_eval: &bool,
    ) -> Ast<N> {
        match self {
            Ast::Add(vec) => add(
                vec.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Mul(vec) => mul(
                vec.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Pow(base, exp) => pow(
                base.eval(evaler, hard_eval),
                exp.eval(evaler, hard_eval),
                evaler,
                hard_eval,
            ),
            Ast::Func(name, args) => func(
                name,
                args.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Const(name) if *hard_eval => {
                if evaler.consts.contains_key(name) {
                    evaler.consts[name]()
                } else {
                    self.clone()
                }
            }
            _ => self.clone(),
        }
    }
\end{lstlisting}

\paragraph{Allgemeine Anmerkungen} Der Generic-Typparameter \codeword{N} soll den gewählten Nummerntyp darstellen. Dieser wird aber noch nicht eingeschränkt, da sonst diese Einschränkungen später für alle implementierenden Blöcke gelten muss. Dies kann z.B. nicht gewünscht sein, wenn eine grundlegend andere Art implementiert werden soll um Terme zu verarbeiten, bei der der Trait \codeword{NumberType} keine Verwendung finden soll. Mit diesem Ansatz kann auch die definierte Ausführungsreihenfolge der Ausprägungen bestimmt werden. Bevor also \codeword{Ast::Add} ausgewertet wird, werden zuerst alle Elemente des Vektors ausgewertet. Eventuelle Vereinfachungen sind dann bereits vorgenommen.

\paragraph{Datenstruktur auf dem Speicher} Mit dieser Implementierung werden nahezu alle Daten auf dem Heap abgelegt. Einzig die Variante \codeword{Ast::Num<PrimNum>} kann komplett auf dem Stack abgelegt werden, da diese eine definierte Größe hat. String und Vec speichern die Daten auf dem Heap und halten nur einen Zeiger auf dem Stack, falls es das oberste Element ist. Box legt die Daten wie bereits besprochen aus Gründen der ungewissen Speicheranforderung auch auf dem Heap an, lediglich der Zeiger kann sich auf dem Stack befinden.

Zwei konkrete Beispiele sollen dies veranschaulichen. Der String bei \codeword{Symbol(x)} wird intern als Vektor mit dem Typ \codeword{u8} repräsentiert \cite{StringSrc}.
\begin{lstlisting}[language=rust, caption={Term 1 Stack und Heap}]
    let term = Ast::Num(PrimNum::Int(42));
    Stack:
    Ast::Num
    +---------------+
    |  PrimNum::Int |
    |  +------+     |
    |  |  42  |     |
    |  +------+     |
    +---------------+
\end{lstlisting}

\begin{lstlisting}[language=rust, caption={Term 2 Stack und Heap}]
    let term = Ast::Add(vec![
        Ast::Num(PrimNum::Int(1337)),
        Ast::Symbol("x".to_owned()),
        Ast::Mul(vec![
            Ast::Num(PrimNum::Float(1.1)),
            Ast::Pow(
                Box::new(Ast::Num(PrimNum::Int(2))),
                Box::new(Ast::Num(PrimNum::Int(2))),
            ),
        ]),
    ]);
    Stack:
    Add(Vec) (Beispielhaft, hier fehlt z.B. noch die capacity)
    +-------+-------+
    |  ptr  |  len  |
    +---|---+-------+
        v
    Heap:
    Num(Int)  Symbol(Vec<u8>)  Mul(Vec)
    +-------- +----------------+---------------+
    |  1337   |  ptr  |  len   |  ptr  |  len  |
    +---------+---|------------+---|-----------+
                  v                v
              +-------+     Num(Float)  Pow
              |  120  |     +-----------+---------------+
              +-------+     |  1.1      |  ptr  |  ptr  |
                            +-----------+---|-------|---+
                                            v       v
                                        Num(Int)  Num(Int)
                                        +--------+--------+
                                        |  2     |  2     |
                                        +--------+--------+
\end{lstlisting}

\newpage

\section{Parser für mathematische Ausdrücke}
Ziel dieses Kapitels ist die Nutzung bzw. Implementierung der lexikalischen Analyse bzw. eines Parsers um Terme in das Enum \codeword{Ast} zu überführen. Erst hier sollen Vereinfachungen und Zusammenfassungen gemacht werden. 
\subsection{Prüfung von bestehenden Bibliotheken zum Parsen}
\paragraph{mexprp Rust} \cite{CrateMexprp} Diese Bibliothek wurde geprüft, da einerseits beim Parsen eine beliebige Genauigkeit möglich ist. Andererseits schien nach einem kurzen Blick in den Code es auch möglich den Term einfach in unsere gewünschte Form zu bringen, da das Enum \codeword{Term} anscheinend einen Abstract Syntax Tree implementiert wie am Anfang angedacht. Über diesen müsste nur einmal iteriert werden um zu unserer modifizierten Version zu gelangen.

Die Abhängigkeit ``rug'' soll die beliebige Genauigkeit ermöglichen. Dabei handelt sich um ein Interface zu den GNU-Bibliotheken GMP, MPFR, MPC. Für diese müssen aber unter GNU/Linux, macOs und Windows jeweils andere Abhängigkeiten installiert werden. Ein schnelles Testen auf anderen Rechnern ist somit ausgeschlossen. Aus diesem Grund wird diese Bibliothek nicht verwendet. Ebenso wird deshalb ``rug'' nicht als Bibliothek für die beliebige Genaugikeit verwendet, sondern num und bigdecimal.

\paragraph{meval Rust} \cite{CrateMeval} Diese Bibliothek erscheint recht unkompliziert und einfach zu nutzen. Die geparsten Tokens werden als UPN (umgekehrte polnische Notation) ausgewertet. Dies könnte man prinzipiell dazu nutzen unseren modifizierten Ast zu erzeugen. Ein kleiner Nachteil ist, dass nur Fließkommazahlen ausgewertet werden. Sollte man den Lexer irgendwann erweitern wollen, sodass eine beliebige Genauigkeit erreicht werden soll, müsste man diesen Part neu schreiben. Zudem habe ich diese Bibliothek leider nicht bei meiner initialen Recherche in Betracht gezogen und nicht weiter überprüft. Erst während der Entwicklung habe ich Interessehalber weiter reingesehen und die Enums \codeword{Operator} und \codeword{Token} größtenteils übernommen. Hätte ich den Lexer nicht bereits zu einem großen Teil implementiert, hätte ich die Möglichkeit genutzt, die Tokens aus dieser Bibliothek zu erzeugen.

\paragraph{evalexpr Rust} \cite{CrateEvalexpr} Diese Bibliothek erscheint sehr umfangreich. Allerdings lässt sich eigentlich nur die \codeword{eval}-Funktion nutzen, da fast alle anderen Strukturen nicht mit dem Schlüsselwort \codeword{pub} versehen sind. Es war mir daher nicht möglich, den Tokenizer bzw. den Baum direkt zu nutzen, in dem sich ein bereits geparster String befindet. Daher schied diese Bibliothek ebenfalls aus.

\paragraph{tinyexpr C} \cite{CTinyexpr} Da es in Rust auch möglich ist, bereits bestehenden C-Code zu nutzen, wurde ebenfalls geprüft eine einfache C-Bibliothek zu nutzen, sodass auch das die notwendige Schnittstelle des Parsers nicht allzu kompliziert wird. Hier habe ich mir tinyexpr näher angesehen. Leider müssen Variablen bereits vor der lexikalischen Analyse zumindest bekannt sein \cite{CTinyexprReadme}. Da ich mich generell gegen diesen Schritt entschieden habe, wurde auch diese Bibliothek nicht verwendet.

\paragraph{Fazit} Eine geeignete Bibliothek zu finden, die den Anwendungszweck erfüllt und dabei nicht allzu weit weg vom eigentlich Ziel ist, ist leider in meinen Augen nicht möglich gewesen. Daher wurde sowohl die lexikalische Analyse als auch das Parsing selbst implementiert. Die wichtigsten Eigenschaften hierzu habe ich aus dem Kurs 01810 Übersetzerbau herausgearbeitet, den ich im Wintersemester 17/18 belegt habe.

\subsection{Implementierung der lexikalischen Analyse bzw. Tokenizer} In diesem Schritt soll aus einer übergebenen Zeichenkette ein Vektor mit Tokens erstellt werden. Hierbei wird zeichenweise gearbeitet und nicht über reguläre Ausdrücke. Eine Besonderheit in Rust ist, dass ein Char in einem String nicht über einen Index referenziert werden kann. Da Strings als UTF-8 gespeichert werden, ist mit dem Index nicht eindeutig, ob das entsprechende Byte oder Zeichen angesprochen werden soll. Daher muss der String hier erst in einen Vektor des Typ \codeword{Char} umgewandelt werden.

Die Tokens werden dabei wieder als Enum implementiert. In diesem Abschnitt verzichten wir auf Generics und implementieren den \codeword{struct} nur für den Typ \codeword{PrimNum}.

Im Enum benötigen wir folgende Werte:
\begin{lstlisting}[language=rust, caption={Enum Token}]
pub enum Token {
    LParen,
    RParen,
    Comma,
    Var(String),
    Func(String),
    Op(Operator),
    Num(PrimNum),
}
\end{lstlisting}

\paragraph{LParen und RParen - linke und rechte Klammer} Diese dienen dazu um Terme zu gruppieren und die eigentliche Operatorenreihenfolge zu verändern, wie es üblich ist in der Mathematik. Es werden die Zeichen ``('' und ``)'' erkannt.

\paragraph{Comma} Dient als Seperator von Funktionswerten.

\paragraph{Var und Func} Eine alphanumerische Zeichenkette, die zwingend mit einem Buchstaben beginnt. Klein- und Großschreibung sind gleichermaßen erlaubt, die Namen beachten die Groß- und Kleinschreibung. Eine Funktion wird daran erkannt, dass nach der Zeichenkette eine öffnende Klammer ``('' anschließt, die zwingend wieder geschlossen werden muss.

\paragraph{Op} Mögliche Operatoren, es wird Beschränkt auf ``+, -, *, /, \^{}''. Der Typ Operator ist dabei wieder ein Enum, der diese Einträge enthält. Im Lexer werden noch keine Anpassungen des Terms vorgenommen.

\paragraph{Num} Eine Zahl, eine Fließkommazahl wird daran erkannt, dass das erste Zeichen ein ``.'' ist oder die gesamte geparste Zeichenkette einen ``.'' enthält. Es sind nur Zahlen erlaubt. Die E-Schreibweise $1.2E10$ wird nicht unterstützt.

\subsection{Implementierung Parser}
Als Parser kommt eine einfache Implementierung der Operator-Vorranganalyse in Frage, wie sie in Kurs 1810  Kurseinheit 3 Kapitel 3.3.2 beschrieben ist \cite[S. 83 ff.]{K1810}. Es handelt sich also um eine Bottom-Up-Analyse. Dabei wird der Algorithmus so implementiert, dass der momentan gültige Operator in einer \codeword{while}-Schleife läuft, um einen Vektor befüllen zu können. Das erste Element des Vektors wird dabei jeweils vor der Schleife geparst, die restlichen Elemente in der Schleife. Dazu werden auch gleich Operatorenüberladungen des \codeword{Ast}-Enum verwendet.

Es handelt sich um einen LR(1)-Parser, da der Parser ein Zeichen vorrausschauen kann, um die nächste Aktion zu bestimmen. Der Stack ist im weitesten Sinne bereits ein gültiges \codeword{Ast}-Element, das befüllt wird. Die \codeword{shift}-Funktion kann als Voranschreiten im Iterator angesehen werden. Die \codeword{reduce}-Funktion entpricht dem Anwenden der Operatorenüberladungen auf dem gültigen \codeword{Ast}-Element.

Beim Parsing von Funktionsargumenten in mathematischen Ausdrücken, fangen die Parameter dabei wieder mit der Funktion zum Parsen von ``+'' und ``-'' an. Auch werden bereits Variablen und Konstanten unterschieden.

Darüberhinaus werden entsprechende Prüfungen eingebaut, sodass der Term $a+b+(c+d)$ nicht wie der folgende Baum geparst wird:

\Tree[.+
        [.a ]
        [.b ]
        [.+
            [.c ]
            [.d ]
        ]
    ]

Es entsteht vielmehr gleich der Baum:

\Tree[.+
        [.a ]
        [.b ]
        [.c ]
        [.d ]
    ]

\newpage

\section{Grundfunktionlitäten}
In diesem Abschnitt sollen Grundlegende Funktionalitäten des CAS implementiert werden. Dies betrifft sowohl den Aufbau des Codes in Rust, um das CAS einfach erweiterbar zu machen, als auch das grundsätzliche Rechnen des Systems. So wird es beispielsweise keine Standardfunktionalität sein, dass $cos(x)^2+sin(x)^2 = 1$ erkannt wird. Dies soll über eine Erweiterung erkannt und verarbeitet werden. Das Zusammenfassen von $x+x=2*x$ ist hingegen aber eine Grundfunktionlität.

\subsection{Änderung des Terms mihilfe von Operatorenüberladung}
Der Trait \codeword{NumberType} soll bereits die meisten nötigen Operatorenüberladungen von den zu implementierenden Typen verlangen. Die wichtigsten Operationen werden ``Add'' und ``Mul'' sein, da diese vom CAS benutzt werden. Operatoren die ebenfalls interessant im weiteren Verlauf sein können sind der Modulo-Operator (z.B. Auswertung der sin- oder cos-Funktion), aber auch die Möglichkeit Werte vergleichen zu können. Deshalb soll noch \codeword{PartialEq} und \codeword{PartialOrd} implementiert werden um die Funktionen ``NumberType == 1'' und ``NumberType > 1'' zu ermöglichen. Daraus ergibt sich die Definition und die Implementierungen für \codeword{PrimNum}:

\begin{lstlisting}[language=rust, caption={trait NumberType 1. Iteration}]
pub trait NumberType:
    + PartialEq<i128>
    + PartialOrd<i128>
    + ops::Add<Self, Output = Self>
    + ops::Mul<Self, Output = Self>
    + ops::Rem<i128, Output = Self>
{}

impl PartialEq<i128> for PrimNum { ,,, }
impl PartialOrd<i128> for PrimNum { ... }
impl ops::Add<PrimNum> for PrimNum { ... }
impl ops::Mul<PrimNum> for PrimNum { ... }
impl ops::Rem<i128> for PrimNum { ... }
\end{lstlisting}

Ebenso soll für das Enum \codeword{Ast} ebenfalls Operatoren überladen werden. Hier beschränken wir uns auf die Operatoren ``Add'' und ``Mul''. Mit dem zusätzlichen Generic-Typ ergibt sich die Defintion:

\begin{lstlisting}[language=rust, caption={Ast Operatorenüberladung}]
impl<N> ops::Add<Ast<N>> for Ast<N>
where
    N: NumberType,
{ ... }

impl<N> ops::Mul<Ast<N>> for Ast<N>
where
    N: NumberType,
{ ... }
\end{lstlisting}

Die Überladungen für \codeword{Ast} sollen dabei gleich Zusammenfassungen übernehmen falls möglich. Das bedeutet konkret für Addition (und entsprechend für Multiplikation):

\begin{lstlisting}[language=rust, caption={smarte Operatenüberladung}]
    Ast::Num(1) + Ast::Num(2) = Ast::Num(3)

    Ast::Add(vec![Ast::Symbol("a"), Ast::Symbol("b")]) +
    Ast::Add(vec![Ast::Symbol("c"), Ast::Symbol("d")]) = 
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Symbol("b"), 
                 Ast::Symbol("c"), Ast::Symbol("d")
                ]
        )

    Ast::Add(vec![Ast::Symbol("a"), Ast::Symbol("b")]) +
    Ast::Num(1) =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Symbol("b"), 
                 Ast::Num(1)
                ]
        )

    Ast::Add(vec![Ast::Symbol("a"), Ast::Num(2)]) +
    Ast::Num(1) =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Num(3)]
        )

    Ast::Add(vec![Ast::Symbol("a")]) +
    Ast::Anderes =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Anderes]
        )

    Ast::Anderes +
    Ast::Anderes =
        Ast::Add(
            vec![Ast::Anderes, Ast::Anderes]
        )
\end{lstlisting}

\label{sec:kapAddnundMult}
\subsection{Addieren und Multiplizieren (Standardauswertung von Termen)}
Die prinzipielle Vorgehensweise um Additionen und Multiplikationen auszuführen, orientiert sich an dem Vorgehen aus SymPy (vgl. \cite{SymPyAddFlatten} und \cite{SymPyMulFlatten}). Beide Verfahren sind im Grunde identisch, nur ändert sich der entsprechende Operator und das Ergebnis. So wird aus $x+x$ eine Multiplikation der Form $2*x$. Aus $x*x$ wird die Potenz $x^2$. 

Das Verfahren wird exemplarisch für die Addition beschrieben, die Multiplikation wird aber ebenfalls im System implementiert. Kernstück ist eine HashMap der Form

\codeword{HashMap<Ast<N>, Ast<N>>}. Key und Wert sind hierbei eigenständige Terme. Der Key ist hierbei der eigentliche Term, der in der Addition auftritt. Der Wert ist sozusagen der Multiplikator wie häufig der Term auftritt. Zudem gibt es einige Sonderfälle. Als Beispiel dient der Term 
$2*x*y + x*y + 3 + a - a$. Um diesen zusammenzufassen, wird über alle Elemente des Vektors iteriert. Die HashMap ist zu Anfang leer, ein gesondertes ``Zahlenergebnis'' wird auf 0 gesetzt.

\begin{itemize}
    \item 1. Wert: Die Multiplikation ist gleich ein Sonderfall. Hier wird versucht eine Zahl aus dem Subterm zu extrahieren, dies ist hier möglich mit der $2$. Die HashMap erhält den Eintrag ``[x*y] = 2''
    \item 2. Wert: Wie davor wird wieder versucht eine Zahl zu extrahieren, was hier nicht gelingt. Bei der Multiplikation können wir also somit das neutrale Element 1 für diesen Subterm hinzufügen. Die HashMap erhält nun den aktualisierten Wert ``[x*y] = 3''
    \item 3. Wert: Alle Zahlen, also unser definierter Nummerntyp, können einfach zu dem Zahlenergebnis addiert werden. Hierzu wird einfach die bereits vorhandene Operatorenüberladung genutzt
    \item 4. Wert: Alle anderen Ausprägungen des \codeword{Ast}-Enum (in diesem Fall Symbol) werden ähnlich der Multiplikation behandelt, nur wird hierbei immer der Wert 1 addiert. Die HashMap erhält hier nun den Wert ``[a] = 1''
    \item 5. Wert: Augenscheinlich wieder ein Symbol. Allerdings wurde bereits erwähnt, dass diese Form intern als $+(-1*a)$ gespeichert wird. Also wird zur HashMap wieder eine Multiplikation hinzugefügt, die den Multiplikator ``-1'' hat. Somit wird die HashMap aktualisiert mit ``[a] = 0''
\end{itemize}

Nachdem diese Vereinfachungen in der HashMap gespeichert sind, besteht die Möglichkeit auf dieser HashMap durch externe Funktionen noch weitere Vereinfachungen vorzunehmen. Dieses Vorgehen wird noch genauer im Kapitel ``\hyperref[sec:kapErRustUndBei]{Erweiterbarkeit in Rust und Beispiele}'' näher erläutert.

Zum Schluss können die Ergebnisse wieder in die Ausprägung \codeword{Ast::Add} überführt werden. Das Zahlenergebnis kann hierbei einfach hinzugefügt werden. Bei der HashMap hängt dies vom Wert zum Key ab. 

\begin{itemize}
    \item Wert == 0: Key wird dem Vektor nicht hinzugefügt
    \item Wert == 1: Key wird dem Vektor hinzugefügt
    \item Alles andere: Es wird dem Vektor ``Ast::Mul(vec![Wert, Key])'' hinzugefügt
\end{itemize}

Um dieses Verfahren zu implementieren, müssen für das \codeword{Ast}-Enum noch die Traits \codeword{Eq}, \codeword{PartialEq} und \codeword{Hash} implementiert werden. Erst dann kann der Typ \codeword{Ast} als Key in der Map verwendet werden. Im einfachsten Fall, kann dies per Makro geschehen. In unserem Fall geht dies aber nur für \codeword{PartialEq}. Da z.B. Vektoren die Traits \codeword{Eq} und \codeword{Hash} nicht implementieren, müssen wir dies selbst erledigen. Der \codeword{Eq} ist dabei aber nur deklarativ, es muss keine Funktion ausgefüllt werden, dies übernimmt der Compiler \cite{RustEqTrait}. Der \codeword{Hash}-Trait kann ebenfalls recht einfach implementiert werden, hier können wir alle vorhandenen Werte als Hash zusammenfassen.

\subsection{Umgang mit Brüchen, Potenzen und Wurzeln}
Um auch genauere Werte zu erlauben, sollen rationale Zahlen in Form von Brüchen implementiert werden. So können mithilfe der Operatorenüberladungen diese dann zusammengefasst und gekürzt werden. Für rationale Zahlen sind im Enum \codeword{PrimNum} für Zähler und Nenner nur ganze Zahlen erlaubt, sowohl jeweils postiv und negativ. Der Term $1/3+1/3$ wird also zu \codeword{Num(Rational(2, 3))} ausgewertet. Der Term $1/3+1/3+1/3$ soll zu \codeword{Num(Int(1))} ausgewertet werden können.

Terme wie $1/x$ werden durch das CAS in die Form \codeword{Pow(Symbol("x"), Num(Int(-1)))} umgeformt. Dabei ist ``x'' entsprechend die Basis und ``-1'' der Exponent. In der Standardimplementierung soll es außerdem bereits möglich sein die Potenzregel $a^{b^{c}} = a^{(b*c)}$ anzuwenden. Durch die bisherige Implementierung der Multiplikation wird außerdem bereits die Potenzregel $x^a*x^b = x^{(a+b)}$ angewendet. Die letzte Regel $x^a*y^a = (x*y)^a$ soll wiederum als erweiterte Funktionalität implementiert werden, da hier eine andere Vorgehensweise bei dem Zusammenfassen des Terms notwendig ist, als die bisher implementierte und im Kapitel zur \hyperref[sec:kapAddnundMult]{Addition und Multiplikation} vorgestellte Vorgehensweise.

Glücklicherweise können Wurzeln ebenfalls als Potenzen dargestellt werden, so ist z.B. $\sqrt{2} = 2^{1/2}$ oder $\sqrt[3]{8} = 8^{1/3}$. So können alle bisherigen Regeln hierrauf einfach angewendet werden. Zudem sollen die Funktionen \codeword{sqrt} und \codeword{nthroot} im Term verwendet werden können, die dann entsprechende \codeword{Ast}-Elemente erzeugen.

Darüberhinaus wird derselbe Algorithmus wie in SymPy implementiert um zu prüfen, ob eine Wurzel eine perfektes Ergebnis liefert \cite{SymPyNewton}. In diesem Fall kann das entsprechende Element vereinfacht werden.

\label{sec:kapErRustUndBei}
\subsection{Erweiterbarkeit in Rust und Beispiele}
Um die Erweiterbarkeit des Systems zu gewährleisten wird das Struct \codeword{EvalFn} eingeführt. Ein Objekt des struct soll zur Evaluierung eines Terms mit angegeben werden. Die hinzugefügten Funktionen des entsprechenden Objekts können dann nach allen Standardoperationen den Term weiter vereinfachen, wie z.B. den angesprochenen Sonderfall $cos(x)^2+sin(x)^2 = 1$, und Konstanten falls gewünscht auswerten. Außerdem wird ein Standard-Objekt vom System bereitgestellt, dass bereits die gängigsten Vereinfachungen vornehmen kann.

\begin{lstlisting}[language=rust, caption={Defintion EvalFn}]
    pub struct EvalFn<N> {
        pub adders: Vec<fn(&mut HashMap<Ast<N>, Ast<N>>, &bool)>,
        pub muls: Vec<fn(&mut HashMap<Ast<N>, Ast<N>>, &bool)>,
        pub pows: Vec<fn(&Ast<N>, &Ast<N>, &bool) -> Option<Ast<N>>>,
        pub funcs: 
            HashMap<String, fn(&Vec<Ast<N>>, &bool) -> Option<Ast<N>>>,
        pub consts: HashMap<String, fn() -> Ast<N>>,
    }
\end{lstlisting}

\paragraph{Allgemeines} Da das Enum \codeword{Ast} bereits einen Generic-Parameter enthält, muss dieser ebenfalls bei EvalFn angegeben werden. Die Felder sind teils Vektoren, teils HashMaps, die entsprechende Funktionen zur Vereinfachung vorhalten. Der Parameter mit dem Typ \codeword{&mut HashMap<Ast<N>} wurde bereits genauer vorgestellt.

\paragraph{adders} Funktionen, die den Typ \codeword{Ast::Add} weiter vereinfachen können. So ist es möglich entsprechend die Einträge der HashMap zu überprüfen und zu verändern. Der zweite Parameter vom Typ \codeword{bool} gibt an, ob es sich um eine explizite Berechnung handelt. Dies wird relevant, wenn auch ungenaue Werte berechnet werden sollen.

\paragraph{muls} Funktionen, die den Typ \codeword{Ast::Mul} weiter vereinfachen können. Die Parameter sind identisch wie bereits bei \codeword{adders}. Dieses Feld ist der Vollständigkeit halber implementiert, da ich kein Beispielterm finden konnte, bei dem dies relevant ist.

\paragraph{pows} Funktionen, die die Basis und den Exponenten erhalten und Auswerten können. So kann z.B. der Term $(x*4)^{(1/2)}$ zu $x^{(1/2)}*2$ vereinfacht werden. Auch hier gibt es wieder die Möglichkeit eine explizite Berechnung zu erwzwingen. Diese Funktion besitzt darüberhinaus einen Rückgabewert, da der entsprechende \codeword{Ast} nicht direkt bearbeitet wird, da sich dieser auch in der Ausprägung verändern kann. In diesem Beispiel wird aus einem \codeword{Ast::Pow} ein \codeword{Ast::Mul}.

\paragraph{funcs} Funktionen, die angegebene Funktionen im Term umschreiben bzw. auswerten sollen. So kann z.B. der Term $sin(0) + 2$ direkt vereinfacht werden in $0 + 2 = 2$. Der Term $sqrt(4)$ kann zu $2$ vereinfacht werden. Dabei bleiben Funktionen, die \codeword{EvalFn} nicht bekannt sind natürlich im Term unverändert erhalten. Falls eine Auswertung nicht möglich ist, ist dies ebenfalls der Fall. Ansonsten steht der Funktion natürlich immer offen den Term entsprechend in ein anderes \codeword{Ast}-Objekt umzuwandeln. Dieses Feld ist als HashMap implementiert, da eine Funktion nur eine Auswertung besitzt.

\paragraph{consts} Funktionen die nur ein \codeword{Ast} zurückgeben. Dies wird in den meisten Fällen ein numerischer Wert sein. Dieses Feld ist ebenso als HashMap umgesetzt.

\subsection{Implementierung von Substitution} Um nun endlich einen Term mit Variablen auszuwerten, müssen wir diese im \codeword{Ast}-Enum substituieren können. Diese Funktionalität kann recht einfach implementiert werden. Hierzu wird die bestehende \codeword{eval}-Methode erweitert, sodass nun auch Variablen überprüft werden. Als zusätzliche Parameter erhält die Methode einen Variablennamen und den zu substituierenden Term. Sind beide gesetzt und es handelt sich bei der Auswertung um die Variable wird der Term anstelle der Variable zurückgegeben. Da Rust keine Methodenüberladung unterstützt, werden ebenfalls Methoden implementiert, die den Funktionsaufruf auch mit weniger Argumenten unterstützen und entsprechend Standardwerte übergeben, die keinen Einfluss auf die Berechnung haben.

Die Erweiterung der Methode besitzt zwei weitere Parameter, den optionalen Variablennamen, der ersetzt werden soll, und das entsprechend \codeword{Ast}, mit dem substituiert werden soll.
\begin{lstlisting}[language=rust, caption={Erweiterung pub fn eval}]
    pub fn eval_sub(
        &self,
        evaler: &EvalFn<N>,
        hard_eval: &bool,
        sub: &Option<&str>,
        with: &Option<&Ast<N>>,
    ) -> Ast<N> {
        match self {
            Ast::Add(vec) => add(
                vec.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Mul(vec) => mul(
                vec.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Pow(base, exp) => pow(
                base.eval_sub(evaler, hard_eval, sub, with),
                exp.eval_sub(evaler, hard_eval, sub, with),
                evaler,
                hard_eval,
            ),
            Ast::Func(name, args) => func(
                name,
                args.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Const(name) if *hard_eval => {
                let mut ret = None;
                for const_struct in evaler.consts.iter() {
                    if let Some(v) = const_struct.eval(&name) {
                        ret = Some(v);
                        break;
                    }
                }

                ret.unwrap_or(self.clone())
            }
            Ast::Symbol(name) if sub.is_some() && name == sub.unwrap() => 
                with.unwrap().clone(),
            _ => self.clone(),
        }
    }
\end{lstlisting}

Zu überlegen ist noch, ob der übergebene Term vor der Substituierung ebenfalls evaluiert wird, oder ob darauf vertraut wird, dass immer ein bereits evaluierter Term übergeben wird.

\subsection{Implementierung von expand}
Unter Umständen ist es interessant einen Term vereinfacht vorliegen zu haben. Auch wenn der Name ``expand'' nicht danach klingt, einen Term zu vereinfachen, so kann dies durchaus der Fall sein, wie der folgende Term zeigt $(x + 1)*(x - 2) - (x - 1)*x$ \cite{SymPyExpand}. Wird der Term ausmultipliziert kann dieser anschließend auf $-2$ vereinfacht werden. Im folgenden sollen die folgende Terme auf dieser Art vereinfacht werden können.

\paragraph{Multiplikation von Additionen bzw. einzelnen Elementen} Hierbei soll der Term $x*(a+b)$ zu $x*a+x*b$ umgeformt werden, der Term $(a+b)*(c+d)*e$ soll entsprechend zu $a*c*e + a*d*e + b*c*e + b*d*e$ umgeformt werden.

Die Implementierung hiervon ist recht einfach. Bei der Ausprägung \codeword{Ast::Mul} wird ein leerer Ergebnisvektor erstellt. Danach muss über jedes Element im Vektor iteriert werden. Handelt es sich nicht um die Ausprägung \codeword{Ast::Add}, wird das Element dem Ergebnis hinzugefügt falls dieser noch leer ist. Ansonsten wird jedes Element im Ergebnisvektor mit dem derzeitigen Element multipliziert, dabei können die Elemente direkt im Vektor verändert werden.

Handelt es sich jedoch um die Ausprägung \codeword{Ast::Add} wird prinzipiell mit demselben Verfahren gearbeitet. Diesmal muss nur zusätzlich über alle Elemente im Vektor von \codeword{Ast::Add} iteriert werden um das derzeitige Element zu bestimmen. Die Veränderung kann nicht direkt im Vektor erfolgen, da ansonsten bereits der Ergebnisvektor verändert wird, bevor alle Elemente mit diesem multipliziert werden konnten.

\paragraph{Potenzen mit ganzzahligen positiven Exponenten} Bei Potenzen der Form $(x+y+z)^n, n \in \mathbb{N}$ kann die entsprechende Basis n-mal in den Vektor für \codeword{Ast::Mul} eingefügt werden. Hiernach kann die expand-Funktion für \codeword{Ast::Mul} aufgerufen werden um den Term auszumultiplizieren. 

\paragraph{Addition im Exponent} Potenzen der Form $n^{x+y}$ sollen in die Form $n^x*n^y$ überführt werden. Die Prüfung kann dabei durch eine einfache \codeword{match}-Anweisung erfolgen. Eine weitere Vereinfachung des Terms ist nach Fertigstellung nicht notwendig.

\paragraph{Potenzen mit Multiplikation in der Basis} Potenzen der Form $(x*y)^a$ sollen in die Form $x^a*y^a$ überführt werden. Die Prüfung kann dabei durch eine einfache \codeword{match}-Anweisung erfolgen.

\paragraph{Beispiel der Erweiterung an der log Funktion} Darüberhinaus soll es wieder einfach möglich sein, für mathematische Funktionen die \codeword{expand}-Methode aufrufen zu können. Hierzu wird das struct \codeword{EvalFn} erweitert.

\begin{lstlisting}[language=rust, caption={EvalFn nach expand}]
    pub struct EvalFn<N> {
        ...
        pub expand_funcs: 
            HashMap<String, fn(&Vec<Ast<N>>) -> Option<Ast<N>>>,
    }
\end{lstlisting}

Das neue Feld ``expand\_funcs'' enthält Funktionen um mathematische Funktionen zu expandieren. So soll z.B. aus $log(x^z*y)$ zu $z*log(x)+log(y)$ werden. Zuordnungen zu Funktionen finden wieder über eine HashMap statt.

\paragraph{Besonderheiten mit Rust} Bei der Implementierung dieser Methode sind das strenge Typensystem von Rust als auch das Ownership und Borrowing in Erscheinung getreten. Explementarisch soll dies an zwei Beispielen erläutert werden, da sich dieses Verhalten ähnlich in anderen Fällen wiederholt.

Für das Enum \codeword{Ast} wurden die Methoden \codeword{shorten} und \codeword{sort} implementiert um generell die Handhabung des Typen zu verbessern. Beide Methoden erhalten eine veränderbare Referenz auf das eigene Objekt und geben auch solch eine wieder zurück. Die Implementierung von \codeword{expand} gibt allerdings eine eigenständige Instanz von \codeword{Ast} zurück und gibt somit das Ownership in diesem Fall ab. Da \codeword{Ast} nicht den Copy-Trait implementieren kann, kann der entsprechende Rückgabewert von \codeword{shorten} und \codeword{sort} nicht einfach dereferenziert werden.

Um das Problem zu umgehen bieten sich zwei Lösungen an. Einerseits kann das zurückgegebene Objekt mit \codeword{.clone()} geklont und als eigenständiges Objekt zurückgeben werden oder es werden die Funktionen auf dem Objekt aufgerufen um danach das Objekt als solches zurückgegeben.

\begin{lstlisting}[language=rust, caption={Mögliche Lösungen für Rückgabewerte}]
    // 1. Möglichkeit
    Ast::Add(result).shorten().sort().clone()

    // 2. Möglichkeit
    let mut result = Ast::Add(result);
    result.shorten().sort();

    result
\end{lstlisting}

Das zweite Beispiel bezieht sich auf das explizite Klonen des Exponenten bei Potenzen, wenn die Basis eine Multiplikation ist. In der entsprechenden for-Schleife wird für jedes Element des Vektors der Basis dem Ergebnis ein neues hinzugefügt nach den oben genannten Regeln. Der Exponent bleibt aber in jedem Durchlauf dersselbe. Da \codeword{Ast} einerseits immer noch nicht den Copy-Trait implementiert und andererseits die Initialisierung von Box das Ownership des Wertes bekommt muss hier \codeword{.clone()} ausgeführt werden. Alle anderen \codeword{.clone()}-Aufrufe dieser Methode beheben prinzipiell dasselbe Problem.

\subsection{Implementierung von simplify}
Um andere Arten von Vereinfachungen vorzunehmen, wird die Methode ``simplify'' in Anlehnung von SymPy \cite{SymPySimplify} erstellt. Hier werden verschiedene Möglichkeiten geprüft einen Term effizient zu vereinfachen.

In dieser Arbeit sollen folgende Terme vereinfacht werden können:

\begin{enumerate}
    \item $a^x * b^x$ wird zu $(a*b)^x$.
    \item $(x^3+x^2+x+1)/y/x*(y^2+y)/z$ wird zu $(x^2+x+1+\frac{1}{x})*(y+1)/z$ Wichtig hierbei ist, dass die Divisoren richtig zugeordnet werden und eine möglichst große Vereinfachung bewirken.
    \item Als Beispiel soll wieder die log-Funktion als Erweiterung implementiert werden. So wird aus $2*log(x)+log(b)$ der Term $log(x^2*b)$.
\end{enumerate}

Die zentrale Frage ist hierbei, wie die Komplexität eines Terms ermittelt wird. Die Standardimplementierung von SymPy zählt hierzu im Term die nötigen Operationen. So erhält der Term $(x**2+x+1)/y$ einen Wert von 4. In dieser Arbeit soll die Komplexität ebenfalls so ermittelt werden. Hierzu wird die Methode \codeword{count_ops} implementiert.

Da sich die ersten beiden Regeln zum Vereinfachen überschneiden können, soll darüberhinaus angegeben werden, welche Art der Vereinfachung durchgeführt werden soll.

\paragraph{Regel 1} Die am einfachsten zu implementierende Möglichkeit der Vereinfachung ist die erste Regel. Hierzu werden in einem \codeword{Ast::Mul} alle Werte iteriert und wie bereits in der Standardauswertung eine HashMap befüllt. Diesmal ist der Key der HashMap allerdings der Exponent und der eigentliche Wert die Basis. Zum Schluss wird für jeden Eintrag entsprechend ein neues \codeword{Ast::Pow}-Element erzeugt und dem Ergebnis hinzugefügt.

\paragraph{Regel 2} Bei der zweiten Regel ist die Zuordnung der Divisoren zu den Additionstermen eine Schwierigkeit, die gelöst werden muss. Schlussendlich habe ich mich für eine Lösung entschieden, die jedem Divisor einem Dividenden zuordnet, die die größte Einsparung erbringt, diese Kombination wird dann durchgeführt. Die Zuordnung läuft dabei so ab, dass alle möglichen Divisoren für alle möglichen Dividenden geprüft werden. Hierbei wird die Komplexität des Terms davor und nach Durchführung der Division gemessen und verglichen.

SymPy löst dies anders. Der Term $(x^3+x^2+x+1)/x*(x^2+x)$ wird hierbei ausmultipliziert und dann ein größter gemeinsamer Teiler gesucht (vgl. \cite{SymPySimplifySrc} Aufrufe \codeword{cancel}, \codeword{_mexpand}, \codeword{together}). Einerseits erscheint mir diese Möglichkeit sehr mächtig, aber auch recht komplex und fehleranfällig zu implementieren.

Um meine bisher gesammelten Erfahrungen in diese Arbeit zu bringen, habe ich mich für eine eigene Implementierung entschieden. Bei einem späteren Vergleich zwischen SymPy und diesem System, können eventuelle Unterschiede aufgezeigt und verglichen werden.

\paragraph{Regel 3} Die letzte Regel soll es erlauben, benutzerdefinierte Regeln zur Zusammenfassung hinzuzufügen. Hierzu wird wieder das Struct \codeword{EvalFn} erweitert, um Funktionen hinzufügen zu können, die nacheinander aufgerufen werden. Als Beispiel dient hierbei die \codeword{log}-Funktion, die nun das Gegenteil wie in ``expand'' macht. Eine Besonderheit hierbei ist, dass diese Funktion sowohl in Multiplikationstermen als auch in Additionstermen aufgerufen werden muss.

\paragraph{Besonderheiten mit Rust} Gerade bei der Implementierung der zweiten Regel ist der Aspekt ``Borrowing'' hervorgetreten. Die ursprüngliche Idee ist, im Term alle Summen und alle anderen Terme zu trennen. Hiernach sollte über alle Summen iteriert werden und der richtige Divisor gefunden werden. Sollte sich bei einer späteren Summe herausstellen, dass der Divisor eine größere Einsparung bringt, soll die vorherige Summe noch einmal mit anderen Divisoren überprüft werden. Allerdings ist es durch das ``Borrowing'' nicht möglich einem Vektor ein Element hinzuzufügen, über den gerade iteriert wird.

Die Lösung wird dabei folgendermaßen implementiert. Durch ein zweites Array wird gespeichert, ob es noch ein Element gibt, das überprüft werden muss. Dies geschieht durch einen ``bool''-Wert am entsprechenden Index. Nach der Iteration muss der entsprechende Index im Hilfsarray auf ``true'' gesetzt werden. Im Falle, dass der Divisor wechselt, muss der entsprechende Index auf ``false'' gesetzt werden. Die Schleife läuft dann solange wie ein ``false''-Wert im Hilfsarray vorhanden ist.

\newpage

\section{Erweiterte Funktionalitäten (Beispiele)}
Die bisherige Implementierung des CAS ist noch rudimentär. Es wurden lediglich die wichtigsten Eigenschaften implementiert um Terme möglichst weit und genau zusammenzufassen.
Die weiteren Implementierungen sollen nun einen Ausblick darauf geben, wie erweiterte Funktionalitäten implementitert werden können aufgrund der geschaffenen Basis. 

\label{sec:ungenauigkeitenKapitel}
\subsection{Terme mit Fließkommazahlen berechnen und Ungenauigkeit in Kauf nehmen} Um ein einzelnes numerisches Ergebnis zu erhalten, sofern alle Variablen im Term substitutiert sind, erhält das \codeword{Ast}-Enum zusätzlich die Methode \codeword{hard_eval}. Diese ruft die bereits vorgestellte Methode \codeword{eval_sub} auf und übergibt als Parameter, dass eine explizite Berechnung stattfinden soll. Dies kann mit einer gewissen Ungenaugkeit verbunden sein.

Dem Parameter \codeword{hard_eval} sollen dabei alle berechnenden Funktionen - insbesondere auch später hinzugefügte Funktionen - weitergegeben werden. Dies kann durch die Typdefinition von EvalFn sichergestellt werden.

Als konkretes Beispiel wird die bestehende Funktion \codeword{perfect_nth_root} erweitert. Als Rückgabewert ist das Enum \codeword{Option} angegeben worden. Bisher gibt diese Funktion \codeword{None} zurück, wenn es sich um kein exaktes Ergebnis handelt. Ansonsten wird ein entsprechendes \codeword{Ast}-Element zurückgegeben.

Wenn nun \codeword{hard_eval} auf ``true'' gesetzt ist, soll die Potenz ohne weitere Prüfung durchgeführt werden, falls es sich um Zahlen handelt. Dazu muss das trait \codeword{NumberType} noch die Methodendefinition \codeword{pow} forden, die in den eigenen Nummerntypen implementiert werden muss. In unserem Fall für \codeword{PrimNum} werden danach die entsprechenden Rust-Funktionen der primitiven Typen aufgerufen um eine Potenz zu berechnen.

Als erstes Beispiel dient der Term $sqrt(2)$. Der Parser erkennt hierbei nur die Funktion. Bei einem Aufruf von \codeword{simple_eval} wird diese Funktion dann durch die bestehende Implementierung nach \codeword{Pow(Num(Int(2)), Num(Rational(1, 2)))} umgewandelt. Der Aufruf von \codeword{hard_eval} dagegen gibt den Fließkommawert \codeword{1.4142135623730951} zurück, wodurch bereits eine Ungenauigkeit entstanden ist.

Als zweites Beispiel dient der Term $sqrt(2)*sqrt(2)$. Durch die gewährleistete Ausführungsreihenfolge der Terme ist das Ergebnis mit \codeword{simple_eval} $2$. Dies kommt durch die Termzusammenfassung zustande, wie sie für die Addition erläutert ist. Bei der Ausführung mit \codeword{hard_eval} wird dagegen entsprechend das Ergebnis $2.0000000000000004$ zurückgegeben. Dies hat den Grund, da ja erst die Potenzen ausgeführt werden und danach erst die Multiplikation durchgeführt wird. Andere Nummerntypen, die hier eine höhere Genauigkeit erlauben bzw. solche Sonderfälle abfangen, können hierbei natürlich auch immer noch ein genaueres Ergebnis liefern.

\subsection{Implementierung der limit-Funktion}
Ursprünglich war geplant, dass die ``limit''-Funktion als Beispiel implementiert wird, wie dynamisch Funktionen dem CAS hinzugefügt werden können. Da dies aber tatsächlich bereits z.B. mit der Wurzelfunktion geschehen ist, kann sich auf die eigentliche Implementierung konzentriert werden. In dieser Arbeit werden nur einige heuristiken der ``limit''-Funktion implementiert \cite{ListLimitHeuristic}.

Die Arbeit von Dominik Gruntz ``On Computing Limits in a Symbolic Manipulation System'' \cite{GruntzPdf} stellt darüberhinaus noch weitere Methoden vor, wie Limits berechnet werden können und besitzt einen eigenen Algorithmus, der neben Heuristiken in SymPy verwendet wird \cite{SympyLimitNote}. Die Implementierung dieser Verfahren soll nicht nicht Teil dieser Arbeit sein.

Bei der Implemeniterung dieser Methode treten keine neuen Probleme mit dem Ownership und Borrowing von Rust auf. Stellen, an denen Werte geklont werden müssen sind nachvollziehbar erkennbar. So müssen z.B. bei der Übergabe der Parameter bei einem rekursiven Funktionsaufruf diese geklont werden, da ansonsten entsprechend das Ownership abgegeben wird. Die bisherigen Implemeniterungen von \codeword{traits} zur Prüfung auf Gleichheit mit Ganzzahlen von \codeword{Ast} und \codeword{NumberType} sind auch hier ausreichend.

Als Ergänzung wurde die $\infty$-Konstante hinzugefügt, die nun auch während des Parsens erkannt wird. Darüberhinaus wurde die \codeword{shorten}-Methode erweitert, um \codeword{Add}- und \codeword{Mul}-Vektoren entsprechend zu behandeln, sofern die $\infty$-Konstante vorhanden ist. So wird z.B. $2*\infty$ zu $\infty$ vereinfacht.

\subsection{Terme leserlich darstellen}
Bisher wurde zur Ausgabe des Terms im \codeword{println!}-Makro der Platzhalter ``\{:?\}'' verwendet. Dieser erlaubt es \codeword{structs} und \codeword{enums} ohne weitere Formatierung auszugeben. In unserem Fall wird z.B. für den Term $-1+y+x*2+x^2$ die Ausgabe
\begin{quote}
    Add([Mul([Num(Int(2)), Symbol("x")]), Pow(Symbol("x"), Num(Int(2))), Symbol("y"), Num(Int(-1))])
\end{quote}
erzeugt. Da dies noch recht unleserlich ist und die übliche Notation die Potenz an den Anfang stellen würde, wird der Trait \codeword{Display} implementiert.

Sobald dieser implementiert ist, kann die Ausgabe auch mit \codeword{println!("{}", ast)} erfolgen. Für das Trait kann die Methode \codeword{fmt} überladen werden, die dann aufgerufen wird. Hier können die Vektoren von Add und Mul entsprechend sortiert werden, sodass eine übliche Ausgabe erfolgt. Die Implementierung in dieser Arbeit gibt für den oben genannten Term $x^2+2*x+y-1$ aus.

\newpage

\section{Vergleich zu SymPy}
\subsection{Korrektheit und Unterschiede gegenüber SymPy}
Um beurteilen zu können, ob das entwickeltes System richtig rechnet, soll mit verschiedenen Termen geprüft werden, ob SymPy diesselben Ergebnisse berechnet. Unterschiede zwischen Ergebnissen werden näher betrachtet.

\begin{table}[h!]
    \caption{Numerische Berechnungen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $1+2+3+4-5$ & $5$ & $5$ \\
        \hline
        $1*2*3*4$ & $24$ & $24$ \\
        \hline
        $1*2*3*4*0$ & $0$ & $0$ \\
        \hline
        $1*2*3*4*(-1)$ & $-24$ & $-24$ \\
        \hline
        $2+3*4+5$ & $19$ & $19$ \\
        \hline
        $(2+3)*(4+5)$ & $45$ & $45$ \\
        \hline
        $2^{3^4}$ & $2417851639229258349412352$ & $2417851639229258349412352$ \\
        \hline
        $0.1+0.2$ & $0.30000000000000004$ & $0.300000000000000$ \\
        \hline
        $3^{-1} + 3^{-1}$ & $\frac{2}{3}$ & $\frac{2}{3}$ \\
        \hline
        $3^{-1} * 3^{-1}$ & $\frac{1}{9}$ & $\frac{1}{9}$ \\
        \hline
        $\sqrt{2}$ & $2^\frac{1}{2}$ & $\sqrt{2}$ \\
        \hline
        $\sqrt{2}+\sqrt{2}$ & $2*2^\frac{1}{2}$ &  $2*\sqrt{2}$ \\
        \hline
        $\sqrt{2}*\sqrt{2}$ & $2$ & $2$ \\
        \hline
    \end{tabular}
\end{table}

Bei dieser Gegenüberstellung fallen zwei Unterschiede auf. Zum einen tritt das Anfangs beschriebene Problem der Ungenauigkeit auf. Eine Lösung hierfür ist die Benutzung von \hyperref[sec:NumTypes]{PrecisionNum}.

\begin{lstlisting}[language=rust, caption={PrimNum vs. PrecisionNum}]
    let a1 = Ast::Num(PrimNum::Float(0.1));
    let a2 = Ast::Num(PrimNum::Float(0.2));
    println!("{}", a1 + a2);
    // 0.30000000000000004

    let a1 = Ast::Num(PrecisionNum::Float(
            BigDecimal::from_str("0.1").unwrap()));
    let a2 = Ast::Num(PrecisionNum::Float(
            BigDecimal::from_str("0.2").unwrap()));
    println!("{}", a1 + a2);
    // 0.3
\end{lstlisting}

Der zweite Unterschied ist die Ausgabe von $\sqrt{2}$. In unserem System wird diese als Potenz ausgegeben, in SymPy als Funktion. Diese Darstellung ist aber nur kosmetisch. Wird der Term in SymPy mit \codeword{sympy.srepr(expr)} ausgegeben, ist die Struktur des Terms zu sehen. SymPy wandelt die $sqrt$-Funktion ebenfalls in eine Potenz um, und gibt diese in diesem speziellen Fall formatiert aus.

\begin{table}[h!]
    \caption{Terme mit Variablen zusammenfassen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $x+x+2*x$ & $4*x$ & $4*x$ \\
        \hline
        $2*x-x-x+y$ & $y$ & $y$ \\
        \hline
        $x+x+a*x$ & $a*x+2*x$ & $a*x + 2*x$ \\
        \hline
        $a*x-x-x+y$ & $a*x-2*x+y$ & $a*x - 2*x + y$ \\
        \hline
        $x*0$ & $0$ & $0$ \\
        \hline
        $x*x$ & $x^2$ & $x^2$ \\
        \hline
        $x^2*x$ & $x^3$ & $x^3$ \\
        \hline
        $x^a*x$ & $x^{a+1}$ & $x*x^a$ \\
        \hline
        $x/x$ & $1$ & $1$ \\
        \hline
        $x^2/x$ & $x$ & $x$ \\
        \hline
        $x^a/x$ & $x^{a-1}$ & $x^a/x$ \\
        \hline
        $a*x+b*x$ & $a*x+b*x$ & $a*x+b*x$ \\
        \hline
        $a^x*b^x$ & $a^x*b^x$ & $a^x*b^x$ \\
        \hline
        $x^a*x^b$ & $x^{a+b}$ & $x^a*x^b$ \\
        \hline
    \end{tabular}
\end{table}

Bei der Zusammenfassung von Variablen tritt ein Unterschied bei den Termen $x^a*x$, $x^a/x$ und $x^a*x^b$. In unserem System werden durch die implementierte Logik vermehrt die Potenzen zusammengefasst, was in SymPy standardmäßig nicht der Fall ist.

\begin{table}[h!]
    \caption{Terme mit Variablen substituieren}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $2+x$, $x=3$ & $5$ & $5$ \\
        \hline
        $2+x$, $x=-3$ & $-1$ & $-1$ \\
        \hline
        $2-x$, $x=-3$ & $5$ & $5$ \\
        \hline
        $2+x$, $x=0.5$ & $2.5$ & $2.50000000000000$ \\
        \hline
        $2^{x} + 2^{x}$, $x=2$ & $8$ & $8$ \\
        \hline
        $2^{x} + 2^{x}$, $x=-1$ & $1$ & $1$ \\
        \hline
        $\sqrt{x}$, $x=3$ & $3^{\frac{1}{2}}$ & $sqrt(3)$ \\
        \hline
        $\sqrt{x}$, $x=4$ & $2$ & $2$ \\
        \hline
        $\sqrt{x}$, $x=16$ & $4$ & $4$ \\
        \hline
        $\sqrt{x}$, $x=17$ & $17^{\frac{1}{2}}$ & $sqrt(17)$ \\
        \hline
    \end{tabular}
\end{table}

Die Substituierung wird ebenfalls identisch umgesetzt. Einzig die Ausgabe bei Termen mit Wurzeln ist wie bereits erwähnt unterschiedlich.

\begin{table}[h!]
    \caption{Nutzung der Methode ``expand''}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $(x + 1)*(x - 2) - (x - 1)*x$ & $-2$ & $-2$ \\
        \hline
        $(a+b)*(c+d)*e$ & \makecell{$a*c*e+a*d*e$ \\ $+b*c*e+b*d*e$} & \makecell{$a*c*e + a*d*e$ \\ $ + b*c*e + b*d*e$} \\
        \hline
        $(a+b)^3$ & \makecell{$a^3+b^3+3*a^2*b$ \\ $+3*b^2*a$} & \makecell{$a^3 + 3*a^2*b + 3*a*b^2$ \\ $+ b^3$} \\
        \hline
        $x^{a+b}$ & $x^a*x^b$ & $x^a*x^b$ \\
        \hline
        $x^{a*b}$ & $x^{a*b}$ & $x^{a*b}$ \\
        \hline
        $(x+y)^a$ & $(x+y)^a$ & $(x + y)^a$ \\
        \hline
        $(x*y)^a$ & $x^a*y^a$ & $x^a*y^a$ \\
        \hline
        $log(x^2*y)$ & $2*log(x)+log(y)$ & $2*log(x) + log(y)$ \\
        \hline
        $log(x^a*y)$ & $a*log(x)+log(y)$ & $a*log(x) + log(y)$ \\
        \hline
    \end{tabular}
\end{table}

Terme, die mit ``expand'' in beiden Systemen verarbeitet werden, liefern das jeweils das gleiche Ergebnis. Dies ist natürlich nur der Fall, für die in diesem System implementierten Fälle. Andere mathematische Funktionen, die von SymPy korrekt verarbeitet werden, müssten erst nachimplementiert werden. So werden in SymPy ebenfalls trigonomische Funktionen ausgewertet. So wird aus $sin(2*x)$ der Term $2*sin(x)*cos(x)$ \cite{SympyTrigExpand}.

\begin{table}[h!]
    \caption{Nutzung der Methode ``simplify''}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $(x^2 + x)/x$ & $x + 1$ & $x + 1$ \\
        \hline
        $(x^2 + x)*(y^2 + y)/x/y$ & $(y + 1)*(x + 1)$ & $(x + 1)*(y + 1)$ \\
        \hline
        $(x^2 + x)*(y^2 + y)/x/a$ & $a^-1*(x+1)*(y^2+y)$ & $y*(x + 1)*(y + 1)/a$ \\
        \hline
        $(x^3 + x^2 + x)*(x^2 + x)/x$ & $(x^2+x)*(x^2+x+1)$ & $x*(x + 1)*(x^2 + x + 1)$ \\
        \hline
    \end{tabular}
\end{table}

Auch bei der Nutzung von ``simplify'' erhalten wir gleichwertige Ergebnisse. SymPy klammert zusätzlich aber noch gemeinsame Teiler aus, was unser System nicht beherrscht. Dies sieht man vor allem am dritten Beispiel. Beide Terme sind aber in diesem Fall korrekt.

\subsection{Performancevergleich}
Bei diesem Vergleich soll die Laufzeit, der Speicherverbrauch und die CPU-Auslastung in verschiedenen Szenarien verglichen werden. Die verwendete Hardware besteht aus einem ``AMD Ryzen 5 3600X 6-Core Processor'' und 16 GB Arbeitsspeicher mit 3000 MHz (DDR 4). Als Messtool wird die Windows-Version des ``Benchmarks Game'' verwendet \cite{BenchmarkGameHome} \cite {BenchmarkGameSrc}.

Python liegt hierbei aus den offiziellen Quellen in Version 3.9.7 vor \cite{PythonDownload}, der Rust-Compiler besitzt die Version ``rustc 1.60.0'' und wurde mithilfe von ``rustup'' installiert \cite{RustDownload}, die verwendeten ausführbaren Programme wurden als Release-Version kompiliert und so geschrieben, dass der Compiler die Berechnungen nicht wegoptimiert.

Alle Szenarien werden zehn mal ausgeführt und danach zusammengefasst. Die Zeiten sind in Sekunden angegeben, der Speicherverbrauch in Kilobyte und die CPU-Auslastung in Prozent.

\paragraph{1. Szenario} Hier werden alle Berechnungen des vorherigen Kapitels durchgeführt. Alle Terme werden dabei sowohl in SymPy als auch in Rust aus einer Zeichenkette geparst und entsprechend ausgeführt.

\begin{table}[h!]
    \caption{Performance Tests}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 0.625 & 40560 & 6 & 0.000 & 756 & 0 \\
        \hline
        2 & 0.688 & 40488 & 6 & 0.000 & 764 & 0 \\
        \hline
        3 & 0.641 & 40548 & 6 & 0.016 & 768 & 0 \\
        \hline
        4 & 0.641 & 40692 & 6 & 0.000 & 752 & 0 \\
        \hline
        5 & 0.609 & 40576 & 6 & 0.000 & 756 & 0 \\
        \hline
        6 & 0.641 & 40324 & 6 & 0.000 & 756 & 0 \\
        \hline
        7 & 0.609 & 40636 & 5 & 0.000 & 752 & 0 \\
        \hline
        8 & 0.641 & 40648 & 7 & 0.000 & 752 & 0 \\
        \hline
        9 & 0.594 & 40808 & 6 & 0.016 & 772 & 0 \\
        \hline
        10 & 0.641 & 40712 & 6 & 0.000 & 756 & 0 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{2. Szenario} Der Term $a+b+c$ wird einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49 und jede Variable mit einem Schleifenzähler substituiert. Die erste Substitution ist somit $0+0+0$, die zweite $0+0+1$ und die letzte $49+49+49$.

\begin{table}[h!]
    \caption{Performance Addition}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 9.781 & 37796 & 8 & 0.453 & 740 & 7 \\
        \hline
        2 & 9.656 & 37612 & 8 & 0.469 & 732 & 8 \\
        \hline
        3 & 9.859 & 37768 & 8 & 0.438 & 732 & 8 \\
        \hline
        4 & 9.688 & 37760 & 8 & 0.453 & 752 & 8 \\
        \hline
        5 & 9.734 & 37960 & 8 & 0.469 & 756 & 8 \\
        \hline
        6 & 9.766 & 37696 & 8 & 0.453 & 744 & 8 \\
        \hline
        7 & 9.875 & 37740 & 8 & 0.469 & 712 & 8 \\
        \hline
        8 & 9.594 & 37920 & 8 & 0.438 & 736 & 8 \\
        \hline
        9 & 9.609 & 37912 & 8 & 0.453 & 740 & 8 \\
        \hline
        10 & 9.688 & 37964 & 8 & 0.469 & 736 & 8 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{3. Szenario} Der Term $a*b*c$ wird einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49 und jede Variable mit einem Schleifenzähler substituiert. Die erste Substitution ist somit $0*0*0$, die zweite $0*0*1$ und die letzte $49*49*49$.

\begin{table}[h!]
    \caption{Performance Multiplikation}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 12.594 & 37996 & 8 & 0.344 & 792 & 7 \\
        \hline
        2 & 12.812 & 37460 & 8 & 0.344 & 744 & 8 \\
        \hline
        3 & 12.906 & 37852 & 8 & 0.344 & 740 & 8 \\
        \hline
        4 & 12.797 & 37596 & 8 & 0.344 & 740 & 8 \\
        \hline
        5 & 12.719 & 37508 & 8 & 0.359 & 744 & 8 \\
        \hline
        6 & 12.812 & 37856 & 8 & 0.344 & 752 & 8 \\
        \hline
        7 & 12.922 & 37536 & 8 & 0.344 & 744 & 8 \\
        \hline
        8 & 12.547 & 37744 & 8 & 0.344 & 744 & 8 \\
        \hline
        9 & 12.672 & 37424 & 8 & 0.328 & 752 & 8 \\
        \hline
        10 & 12.922 & 37576 & 8 & 0.344 & 744 & 7 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{4. Szenario} In diesem Szenario liegt der Fokus auf den Speicherverbrauch. Es wird wieder der Term $a+b+c$ einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49. Einer am Anfang erstellten Liste bzw. Vektor wird dann sowohl der originale Term als auch die Substituierung wie im 2. Szenario hinzugefügt.

\begin{table}[h!]
    \caption{Speicherverbrauch}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 9.703 & 42608 & 8 & 0.578 & 43792 & 7 \\
        \hline
        2 & 9.891 & 41680 & 8 & 0.484 & 43748 & 7 \\
        \hline
        3 & 9.797 & 42496 & 8 & 0.500 & 43784 & 7 \\
        \hline
        4 & 9.578 & 41668 & 8 & 0.516 & 43788 & 7 \\
        \hline
        5 & 9.750 & 42444 & 8 & 0.500 & 43752 & 8 \\
        \hline
        6 & 9.719 & 42280 & 8 & 0.500 & 43796 & 8 \\
        \hline
        7 & 9.781 & 42448 & 8 & 0.516 & 43792 & 7 \\
        \hline
        8 & 9.734 & 41792 & 8 & 0.500 & 43744 & 7 \\
        \hline
        9 & 9.750 & 42360 & 8 & 0.516 & 43736 & 7 \\
        \hline
        10 & 9.656 & 42552 & 8 & 0.516 & 43792 & 7 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{Beobachtungen} Bei einem Vergleich der Szenarien 1 bis 3 ist wie zu erwarten das kompilierte Programm sowohl schneller als auch Speichereffizienter. Der geringe Speicherverbrauch in Rust lässt sich einerseits auf automatische deallokieren von Variablen zurückführen, wenn diese den Gültigkeitsbereich verlassen. Andererseits gibt es keine Laufzeitumgebung wie in Python. Bei den SymPy-Tests dagegen ist der große Sprung zum Speicherplatzverbrauch auf die SymPy-Bibliothek zurückzuführen.

Wird ein einfaches ``Hello World!'' ausgegeben beträgt der Speicherverbrauch ca. 5000 Kilobyte. Wird im selben Python-Skript zusätzlich SymPy importiert beträgt der Speicherverbrauch bereits ca. 35000 Kilobyte. Da zudem unklar ist, wann genau der Garbage Collector von Python läuft, kann es auch vorkommen, dass noch ungenutzte Variablen den Speicher belegen.

Im ausführbaren Programm von Rust, sind dagegen nur Codeabschnitte, die tatsächlich benögit werden. Nicht benötigte Funktionen aus Abhängigkeiten und dem eigenen Code sind nicht vorzufinden \cite{RustDeadCode1}. Dies kann man sich auch anschaulich mit ``cargo-bloat'' anzeigen lassen \cite{RustDeadCode2}.

Bei Szenario 4 zeigt die Laufzeit wieder ein ähnliches Verhältnis, Rust ist wieder schneller als Sympy. Auf den ersten Blick skaliert aber SymPy wesentlich besser, was den Speicherplatzverbrauch betrifft. Dies ist aber stark Implementierungsabhängig. Da wie anfänglich beschrieben immer der originale Term und das Ergebnis der Liste hinzugefügt wird, muss aufgrund des Ownerships in Rust der originale Vektor immer kopiert werden, da dieser nur einmalig erstellt wird. Bei dem Hinzufügen zur Liste wird dann das Ownership verschoben.

Fügt man in der Python-Version anstelle des originalen Terms die Adresse der Variablen der Liste hinzu und lässt sich diese Ausgeben, fällt auf, dass immer nur eine Referenz hinzugefügt wird, da alle Adressen identisch sind. Lediglich die Ergebnisse unterscheiden sich. Wird der originale Term nicht der Liste hinzugefügt, beträgt der Speicherplatzverbrauch von Rust nur noch ca. 13000 Kilobyte, die Python-Version belegt immer noch ca. 40000 Kilobyte.

Anstelle einer kopierten Version des Terms könnte auch eine Referenz der Liste hinzugefügt werden, dann muss aber wiederrum sichergestellt werden, dass dieser eine größere Lifetime als der Vektor besitzt.

Aus den Ergebnissen kann geschlossen werden, dass Rust im Vergleich zu SymPy eine wesentlich bessere Performance bietet. Dies betrifft zum einen die Laufzeit von Berechnungen, als auch den Speicherplatzverbrauch. Letzteres hängt aber natürlich von den implementierten und verwendeten Funktionen des Systems ab.

\newpage

\section{Fazit}
\subsection{Erweiterungs- und Verbesserungsideen des Systems}
Im Rahmen dieser Arbeit wurde nicht für alle Implementierungen die bestmögliche Lösung vorgenommen. Auch sind einige Aspkete verbesserungswürdig, die für einen angenehmeren Umgang mit dieser Bibliothek sorgen würden. Diese Punkte sollen der Vollständigkeithalber mit aufgeführt werden.
\begin{itemize}
    \item Da Rust keine weiteren Besonderheiten für Rekursion bietet, würde eine iterative Lösung die Elemente des \codeword{Ast} zu verarbeiten wahrscheinlich Performanter sein.
    \item Der Parser könnte erweitert werden, sodass auch $3x$ anstelle von $3*x$ erkannt wird. Auch die Möglichkeit dynamisch Operatoren hinzuzufügen wäre interessant, sodass z.B. für die Fakultät einfach $x!$ angegeben werden kann, anstelle eines Funktionsaufrufs.
    \item Bei der Zusammenfassung der Terme ist zu überlegen, den Nummerntyp nicht zusammenzufassen. Rationale Zahlen und Fließkommazahlen könnten nebeneinander existieren. In der momentanen Implementierung wird diese Addition zu einer Fließkommazahl vereinfacht. Der Vorteil dabei ist, dass sicher nur ein Zahlenwert vorhanden ist. Allerdings wird der Nachteil der Ungenauigkeit in Kauf genommen.
    \item Bei der Zusammenfassung von Termen in der HashMap kann es zu Konflikten kommen. Eine andere Idee wäre hier als Key den Term als String zu verwenden. Hierzu müsste aber der Term auf jeden Fall vorher sortiert sein. Permutationen eines Terms ($x*y$ und $y*x$) können sonst nicht abgefangen werden. Hier hat das Hashing den Vorteil, das die Reihenfolge egal ist, da beide Symbole zusammen denselben Hashwert errechnen.
    \item Im Moment wird $cos(x)^2+sin(x)^2 = 1$ nur in einfachen Fällen zusammengefasst. Der Term $(z*sin(x)^2)+(z*cos(x)^2) + (a*sin(x)^2)+(a*cos(x)^2)$ könnte entsprechend auch zusammengefasst werden.
    \item Erweiterung des heuristischen Verfahrens der ``limit''-Funktion und implementierung des Gruntz-Algorithmus \cite{GruntzPdf}.
\end{itemize}

Bei der Substituierung von Symbolen wären ebenfalls Erweitungen vorstellbar.
\begin{itemize}
    \item Übergabe eines Vektors von Werten, Rückgabewert ist ebenfalls Vektor mit den entsprechenden Substituierungen. Diese könnten sogar nebenläufig umgesetzt werden.
    \item Mehrere Variablen gleichzeitig ersetzen.
    \item Substitution von ganzen Termen erlauben, nicht nur einzelnen Variablen.
    \item Mischformen der Verbesserungen.
\end{itemize}

\subsection{Ausblick}
Am Anfang dieser Arbeit waren die Konzepte Ownership, Borrowing und Lifetimes noch schwer greifbar. Diese wurden als Hürde von mir wahrgenommen, da hierdurch viele Sachen explizit angegeben werden müssen, wie z.B. das klonen von Übergabeparametern oder auch wie teilweise über Elemente iteriert werden muss. Im laufe der Entwicklung des CAS wurden diese Konstrukte aber immer augenscheinlicher und bereiteten schlussendlich keine Probleme mehr. Darüberhinaus kann immer leicht nachvollzogen werden, an welchen Stellen welche Werte verwendet werden mit der Sicherheit, dass diese nicht versehentlich an anderer Stelle überschrieben worden sind. Die Fehleranfälligkeit sinkt dadurch wie in \hyperref[sec:kap2d2]{Kapitel 2.2} gezeigt.

Dieses strenge System in Rust hat sich von einem Nach- zu einem großen Vorteil entwickelt. Verbunden mit einer steilen Lernkurve in Rust, sind dies die einzigen Nachteile, die während der Arbeit mit Rust aufgefallen sind.

Ein weiterer Vorteil von Rust ist die bessere Performance im Gegensatz zu SymPy. Dieser Vorteil dürfte im Vergleich zu anderen Systemen, die in C oder C++, wie z.B. Xcas \cite{XcasLink} geschrieben sind geringer ausfallen. Dies hängt im konkreten Fall vom verwendeten Compiler ab, der die ausführbaren Programme erzeugt. Da Rust wie bereits angesprochen LLVM verwendet würde ein C/C++ Programm kompiliert mit Clang eine ähnliche Performance aufweisen.

Ebenfalls ein Vorteil ist das breite Ökosystem, welches mit ``cargo'' bereitsteht. Das Programm kann einfach mit verschiedenen Profilen kompiliert werden, z.B. als Debug- oder Releaseversion. Abhängigkeiten können installiert und Tests und Bechnmarks einfach ausgeführt werden.

Auch wenn, wie Eingangs erwähnt, Rust derzeit keine große Relevanz im Bereich des wisschenschaftlichen Arbeitens besitzt, so sprechen die genannten Punkte dafür, Rust auch dort zu verwenden.

Gerne veröffentliche nach Absprache mit Frau Prof. Dr. Oden die entstandene Arbeit und stelle diese der Rust-Community zur Verfügung. Eine zukünftige Weiterentwicklung soll nicht ausgeschlossen werden.

\newpage
\bibliographystyle{babplain-fl}
\raggedright
\bibliography{literature}

\end{document}
