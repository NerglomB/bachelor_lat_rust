\documentclass[11pt,a4paper, ngerman]{article}

\usepackage[margin=2.75cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{hologo}
\usepackage{amsmath}
\usepackage{babelbib}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsfonts}
\usepackage{qtree}
\usepackage{makecell}
\definecolor{GrayCodeBlock}{RGB}{245,245,245}
\definecolor{BlackText}{RGB}{10,10,10}
\definecolor{RedTypename}{RGB}{135,58,3}
\definecolor{GreenString}{RGB}{72,125,44}
\definecolor{PurpleKeyword}{RGB}{159,73,183}
\definecolor{GrayComment}{RGB}{70,70,70}
\definecolor{GoldDocumentation}{RGB}{200,185,65}
\lstdefinelanguage{rust}
{
    escapeinside=``,
    columns=fullflexible,
    keepspaces=true,
    showstringspaces=false,
    frame=single,
    framesep=0pt,
    framerule=0pt,
    framexleftmargin=4pt,
    framexrightmargin=4pt,
    framextopmargin=5pt,
    framexbottommargin=3pt,
    xleftmargin=4pt,
    xrightmargin=4pt,
    backgroundcolor=\color{GrayCodeBlock},
    basicstyle=\ttfamily\color{BlackText},
    keywords={
        true,false,
        unsafe,async,await,move,
        use,pub,crate,super,self,mod,
        struct,enum,fn,const,static,let,mut,ref,type,impl,dyn,trait,where,as,
        break,continue,if,else,while,for,loop,match,return,yield,in
    },
    keywordstyle=\color{PurpleKeyword},
    ndkeywords={
        bool,u8,u16,u32,u64,u128,i8,i16,i32,i64,i128,char,str,
        Self,Option,Some,None,Result,Ok,Err,String,Box,Vec,Rc,Arc,Cell,RefCell,HashMap,BTreeMap,
        macro_rules
    },
    ndkeywordstyle=\color{RedTypename},
    comment=[l][\color{GrayComment}\slshape]{//},
    morecomment=[s][\color{GrayComment}\slshape]{/*}{*/},
    morecomment=[l][\color{GoldDocumentation}\slshape]{///},
    morecomment=[s][\color{GoldDocumentation}\slshape]{/*!}{*/},
    morecomment=[l][\color{GoldDocumentation}\slshape]{//!},
    morecomment=[s][\color{RedTypename}]{\#![}{]},
    morecomment=[s][\color{RedTypename}]{\#[}{]},
    stringstyle=\color{GreenString},
    string=[b]"
}

\lstset{literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Codebeispiel}
\renewcommand{\lstlistlistingname}{Verzeichnis der Codebeispiele}

\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

\pagestyle{fancy}
\fancyhf{}
\lhead{\leftmark}
\rhead{\thepage}
\setlength{\headheight}{0.5cm}

\begin{document}

\title{
    \includegraphics[width=5cm]{logo_fernuni_hagen.png}\\
    \ \\
    Fakultät für Mathematik und Informatik\\
    Bachelor of Science Informatik\\
    \ \\
    Bachelorarbeit\\
    \ \\
    \textbf{Ein Computeralgebrasystem in Rust}\\
    \ \\
    \includegraphics[width=5cm]{rust-logo-512x512-blk.png}
}
\author{
    \begin{tabular}{ll}
        Verfasser & Bernd Haßfurther \href{mailto:nerglom@posteo.de}{<nerglom@posteo.de>}\\
        Matrikel-Nr. & 4372280\\
        Betreuerin & Prof. Dr. Lena Oden\\
        Datum & \today\\
    \end{tabular}
}

\date{}
\clearpage\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\lstlistoflistings
\newpage
\listoftables
\newpage

\section{Einleitung}
Computeralgebrasysteme - im Folgenden abgekürzt durch CAS - nehmen in verschiedenen Bereichen der Wissenschaft eine wichtige Rolle ein. Sie ermöglichen es mathematische Ausdrücke mit Variablen darzustellen, diese Terme zu verändern und mit diesen zu arbeiten. Andererseits lassen sich wesentlich genauere Berechnungen durchführen, indem z.B. nicht alle Ausdrücke in einem Term ausgewertet werden, wenn es hierdurch zu Ungenauigkeiten kommen kann. Die ``Fachgruppe Computeralgebra'' beschreibt ein solches System wie folgt:
\begin{quote}
    ``Die Computeralgebra ist ein Wissenschaftsgebiet, das sich mit Methoden zum Lösen mathematisch formulierter Probleme durch symbolische Algorithmen und deren Umsetzung in Soft- und Hardware beschäftigt. Sie beruht auf der exakten endlichen Darstellung endlicher oder unendlicher mathematischer Objekte und Strukturen und ermöglicht deren symbolische und formelmäßige Behandlung durch eine Maschine. Strukturelles mathematisches Wissen wird dabei sowohl beim Entwurf als auch bei der Verifikation und Aufwandsanalyse der betreffenden Algorithmen verwendet. Die Computeralgebra kann damit wirkungsvoll eingesetzt werden bei der Lösung von mathematisch modellierten Fragestellungen in zum Teil sehr verschiedenen Gebieten der Informatik und Mathematik sowie in den Natur- und Ingenieurwissenschaften.'' \cite{FachgruppeDef}
\end{quote}

Anwendungsbeispiele für ein CAS finden sich in der Physik, Chemie, Sicherheitstechnik, Robotik und vielen weiteren Bereichen \cite{FachgruppeEinsatz}. In ``Zum Einfluss von Computeralgebrasystemen auf mathematische Grundfertigkeiten'' werden sowohl Vor- als auch Nachteile bei der Verwendung während der Schulzeit (z.B. wissenschaftliche Taschenrechner) diskutiert \cite[S. 17 ff.]{RN18}. Auch wenn somit augenscheinlich die Verwendung eines CAS viele Bereiche entlasten kann, so sollte immer noch das Hintergrundwissen vorhanden sein, welche Erleichterungen ein CAS übernimmt.

In der vorliegenden Arbeit soll ein CAS in Ansätzen mit der Programmiersprache Rust entwickelt werden. Es soll untersucht werden, inwieweit das Ownership- und Borrowing-System von Rust während der Entwicklung des CAS unterstützt und wie die Performance zur Laufzeit ausfällt. Das System soll dabei einfach erweiterbar sein. Nicht implementierte mathematische Funktionen sollen einfach integriert und Terme weiter zusammengefasst werden können, als die Standardimplentierung erlaubt.

Einen besonderen Stellenwert im Bereich der Computeralgebrasysteme nimmt SymPy ein. Dieses System ist als Open-Source-Projekt verfügbar und in Python geschrieben. Zudem ist der Code leicht verständlich und erweiterbar \cite[S. 1]{SympyPeerJ}. Durch die Verwendung dieser Bibliothek und die Vorstellung der Programmiersprache Rust während meines Studiums enstand die Idee diese Arbeit zu schreiben. Einige Lösungen werden deshalb von SymPy inspiriert sein. Der Code soll dabei nicht 1-zu-1 in Rust neu geschrieben werden, sondern mit den Möglichkeiten und Einschränkungen von Rust erweitert werden, auch wenn nur ein Teil des Umfangs von SymPy in dieser Arbeit abgebildet werden kann.

Die Entwicklung von und mit Rust wird immer relevanter. So wird beispielsweise die Entwicklung für den Linux-Kernel immer weiter vorangetrieben \cite{RustLinux}. Auch für die Entwicklung unter Android \cite{GoogleExample} und Windows \cite{WindowsRust} stehen erste Bestrebungen bereit. Erst letztes Jahr erschienen mit der ``Edition 2021'' \cite{RustEditon2021} neue Features. Für die nächste Version ``Edition 2024'' gibt es ebenfalls bereits eine Roadmap \cite{RustEditon2024}.

Größere Projekte des wissenschaftlichen Bereichs, in denen Rust explizit verwendet wird, sind leider nicht auffindbar. Es gibt jedoch unabhängige Pakete, die einzelne Gebiete der wissenschaftlichen Programmierung abdecken \cite{RustEx1} \cite{RustEx2} \cite{RustEx3}. Weiterhin können Beiträge gefunden werden, die das Thema aufgreifen und zumeist auf den schweren Einstieg hinweisen \cite{RustUse1} \cite{RustUse2} \cite{RustUse3}. Dies soll in der nächsten Version von Rust verbessert werden \cite{RustEditon2024Specific}.

\newpage

\section{Grundlagen CAS}
Das folgende Kapitel definiert den Funktionsumfang des entwickelten CAS. Um einen Überblick über die Größe der Arbeit zu geben, soll näher auf SymPy eingegangen sowie aufgezeigt werden, welche weiteren Implementierungen denkbar wären, wenn der Funktionsumfang mit SymPy verglichen wird.

\subsection{Grundregeln und Annahmen}
Bevor überlegt wird, wie der Aufbau des CAS aussieht und welche Typen benötigt werden, müssen ein einige Vorüberlegungen gemacht werden, welche Grundregeln und Annahmen im System gelten sollen. Ein Teil dieser Regeln stammt aus ``SymbolicC++'' \cite[S. 2]{Tan2000} und ``Algorithms for Computer Algebra'' \cite[S. 23 ff.]{Geddes2007}, andere wiederum sind als Einschränkung oder zur besseren Verständlichkeit im Rahmen dieser Arbeit hinzugefügt worden. Es sollen folgende Zahlenräume betrachtet werden:
\begin{itemize}
    \item $\mathbb{N}$ die Menge der natürlichen Zahlen mit 0, $\{0, 1, 2, 3...\}$
    \item $\mathbb{Z}$ die Menge der ganzen Zahlen, $\{...-3, -2, -1, 0, 1, 2, 3...\}$
    \item $\mathbb{Q}$ die Menge der rationalen Zahlen, $\{...-\frac{2}{1}, -\frac{1}{2}, -\frac{1}{1} 0, \frac{1}{1}, \frac{1}{2}, \frac{2}{1}...\}$
    \item $\mathbb{R}$ die Menge der reellen Zahlen, z.B. $\sqrt{2}$ oder $\pi$
\end{itemize}

Der komplexe Zahlenbereich  $\mathbb{C}$ wird im Rahmen dieser Arbeit nicht betrachtet.

Um insgesamt weniger Bedingungen für mathematische Operationen zu haben, ist geplant verschiedene Vereinfachungen und Bedingungen anzunehmen. So müssen alle Implementierungen nur die Operationen Addieren und Multiplizieren berücksichtigen.
\begin{itemize}
    \item Jede Substraktion ist grundsätzlich eine Addition. Für Zahlen bedeudet dies $5-3 = 5+(-3)$ und für Symbole bzw. Terme anderer Art $a-b = a+(-1 * b)$. Eine Besonderheit sollen Terme der Art $1-(a+b+1)$ darstellen. Diese sollen zu $1+(-1*a)+(-1*b)+(-1)$ umgeformt werden und nicht zu $1+(-1*(a+b+1))$
    \item Bei Divisionen werden Zahlen zu rationalen Zahlen, z.B. $2/3 = \frac{2}{3}$ und $-(2/3) = \frac{-2}{3}$. Symbole und Terme werden zu einer Multiplikation vereinfacht, $a/b = b^{(-1)} * a$ und $(a*b*c)/(d+1) = (d+1)^{-1} * (a*b*c)$
    \item Das Kommutativgesetz soll beachtet werden: $x+y = y+x$ also auch $2*(x+y) + (y+x)*2 = 4*(x+y)$
    \item Das Assoziativgesetz soll beachtet werden: $a+(b+c) = (a+b)+c = a+b+c$
    \item Das Distributivgesetz soll beachtet werden: $a*(x+y) = a*x + a*y$
    \item quelle suchen bücher von oben
\end{itemize}

\subsection{Funktionsumfang}
Da wie bereits in der Einleitung gezeigt, ein CAS sowohl einen sehr breiten Umfang haben, als auch spezialisiert sein kann, muss noch definiert werden, welche Möglichkeiten das in dieser Arbeit entwickelte System besitzt. Konkret soll veranschaulicht werden, welche Operationen erlaubt sein sollen und welche Art von Termen verarbeitet werden können:
\begin{itemize}
    \item Addition von Zahlen (Ganzzahlen, Fließkommazahlen, rationalen Zahlen), z.B. $1+2.1 = 3.1$ oder $\frac{1}{3} + \frac{1}{3} = \frac{2}{3}$
    \item Addition von Symbolen und Termen, z.B. $x+y = x+y$ oder $x+(2*y)+2+(2*y)+x = 2*x+4*y+2$
    \item Multiplikation von Zahlen (Ganzzahlen, Fließkommazahlen, rationalen Zahlen), z.B. $1*2.1 = 2.1$
    \item Multiplikation von Symbolen und Termen, z.B. $x*y*x = x^2*y$
    \item Auswertung von Potenzen die Zahlen, Symbolen und Terme in Basis oder Exponent haben. Dabei sollen Potenzregeln in Hinblick auf Genauigkeit des Ergebnisses ausgeführt werden, z.B. $x^a*x^b=x^{(a+b)}$ oder $x^a*y^a = (x*y)^a$
    \item Auswertung von Funktionen, die dynamisch hinzugefügt werden können. Funktionen die dem CAS nicht bekannt sind, tauchen weiterhin in Termen auf, werden aber nicht ausgewertet, z.B. $sin(x)$ oder $sqrt(x)$
    \item Auswertung von Konstanten falls bekannt und gewollt
    \item Die Ausführungsreihenfolge in Termen lautet: Konstanten und Variablen $\rightarrow$ Funktionen $\rightarrow$ Potenzen $\rightarrow$ Multiplikationen $\rightarrow$ Additionen
\end{itemize}

Darüber hinaus sollen Terme soweit wie möglich mit bereits bestehenden Sprachmitteln erweitert und verglichen werden können. Hierfür werden einige Operatorüberladungen implementiert. Bei der Auswertung der Terme soll die Möglichkeit bestehen eventuell ungenaue numerische Ergebnisse zu berechnen. Funktionen und Konstanten sollen später einfach hinzugefügt werden können.

\subsection{Überblick SymPy}
Das SymPy Projekt beschreibt sich selbst als eine Python-Bibliothek für symbolische Mathematik, die das Ziel hat, ein CAS mit ``vollen Funktionsumfang'' zu werden \cite{SymPyAbout}. Im Gegensatz zu dem hier begrenzten System beherrscht SymPy z.B. das Handling von Matrizen \cite[S. 11]{SympyPeerJ} oder auch physikalische Berechnungen \cite[S. 14 ff.]{SympyPeerJ}. Darüber hinaus können auch 2D- und 3D-Grafiken erstellt werden \cite{SymPyPlot} uvm. \cite[S. 4 ff.]{SympyPeerJ}. Das Projekt existiert seit mindestens 2007 \cite{SymPyFirstCommit} und wird seither stetig weiterentwickelt.

Verwendung findet SymPy in anderen Projekten, die teils wiederum spezifisch sind, z.B. ``ChemPy'' \cite{ChemPy} oder mehrere Abhängigkeiten vereinen, z.B. ``sagemath'' \cite {Sagemath}.

\newpage

\section{Vorstellung der Programmiersprache Rust}
In diesem Kapitel sollen die Grundlagen von Rust erläutert werden. Dabei sollen sowohl die Syntax als auch die grundlegenden Konzepte der Sprache und deren Vorteile vermittelt werden. Einige Stellen zur Vorstellung der Sprache sind meiner Seminararbeit ``Die Programmiersprache Rust'' entommen \cite{Seminararbeit}. Wo nötig, wurden Texte erneuert, erweitert und Quellen aktualisiert.

\subsection{Einführendes Beispiel: Ownership und Borrowing}
Bevor Rust vorgestellt wird und die genauen Regeln des Ownership und Borrowing erläutert werden, soll das Prinzip anhand eines Beispiels verdeutlicht werden. Hierzu wird ein \codeword{struct} - vergleichbar mit Klassen - angelegt, welches z.B. eine große Matrix beinhaltet, die verarbeitet werden soll.

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: struct}]
    struct LargeMatrix {
        matrix: Vec<i32>,
    }
\end{lstlisting}

 In diesem ersten Beispiel wird eine Funktion erstellt, die das Ownership der Matrix übernimmt und nach der Verarbeitung den Speicherplatz freigibt. Dies geschieht automatisch, da der Gültigkeitsbereich der Variable \codeword{matrix_fn} verlassen wird \cite{RustOwnershipFreed}. In diesem Kontext bedeutet Ownership, dass der Wert vom Hauptprogramm in die Funktion verschoben wird und die neue Variable \codeword{matrix_fn} das alleinige Recht besitzt diesen Wert zu nutzen \cite{RustMovingTerm}. Das Programm lässt sich so nicht kompilieren. Die zweite Ausgabe schlägt dabei fehl, da beim Aufruf der Funktion der Wert in die Funktion verschoben und freigegeben wurde. Der Zugriff auf den entsprechenden Speicherbereich im Hauptprogramm ist undefiniert.

 \begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Ownership abgeben}]
    fn take_ownership(matrix_fn: LargeMatrix) {
        // ...
    }

    let matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_ownership(matrix);
    println!("{:?}", matrix); // <- Fehler
\end{lstlisting}

Die zweite Funktion gibt das Ownership der Matrix wieder zurück, der Wert wird also wieder zurückgeschoben und kann nach dem Funktionsaufruf weiter verwendet werden. Dies geschieht jedoch nur, wenn der Variablen im Hauptprogramm der Rückgabewert zugewiesen wird. Hierzu muss die Variable \codeword{matrix} explizit als veränderbar mit dem Schlüsselwort \codeword{mut} definiert werden. Der Nachteil dieser Methode ist, dass nicht klar ist, ob es sich um die originale Matrix handelt, oder um eine neu initialisierte Matrix.

\newpage

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Ownership zurückgeben}]
    fn give_back_ownership(matrix_fn: LargeMatrix) -> LargeMatrix {
        // ...
        // Originale Matrix zurückgeben
        matrix_fn
        // Oder neue Matrix zurückgeben
        // LargeMatrix { matrix: vec![] }
    }

    let mut matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    matrix = give_back_ownership(matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Im nächsten Beispiel erhält die Funktion lediglich eine Referenz auf die Matrix. Dies ist durch das \codeword{&}-Zeichen gekennzeichnet. In Rust wird dieses Prinzip als ``Borrowing'' bezeichnet \cite{RustBorrowing}. Wie bereits im ersten Beispiel wird beim Verlassen der Funktion der Speicherplatz der Variablen freigegeben. Diesmal handelt es sich aber nur um den Zeiger und nicht um die eigentlichen Daten. Eine Verwendung nach dem Funktionsaufruf ist daher weiterhin möglich.

Da Variablen in Rust standardmäßig unveränderbar sind, ist ebenso sichergestellt, dass die Matrix in der Funktion nicht verändert worden ist \cite{RustVariablesAndMutability}. 

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Unveränderliche Referenz}]
    fn take_reference(matrix_ref: &LargeMatrix) {
        // ...
    }

    let matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_reference(&matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Im letzten Beispiel soll durch die Verwendung des \codeword{mut}-Schlüsselworts ermöglicht werden, die Daten der originalen Matrix zu verändern. Ansonsten gibt es keine Änderung zum vorherigen Beispiel. Beim Verlassen der Funktion wird ebenfalls wieder nur der Zeiger freigegeben \cite{RustOwnershipFreed}.

\begin{lstlisting}[language=rust, caption={Einführendes Beispiel: Veränderliche Referenz}]
    fn take_mutable_reference(matrix_ref: &mut LargeMatrix) {
        matrix_ref.matrix[0] = 0;
        // ...
    }

    let mut matrix = LargeMatrix { matrix: vec![] };
    println!("{:?}", matrix);
    take_mutable_reference(&mut matrix);
    println!("{:?}", matrix);
\end{lstlisting}

Die beiden letzten Funktionen können auch einen Rückgabewert besitzen, der unabhängig von der übergebenen Matrix ist. Eine besondere Stärke sind die Regeln, die für das Borrowing gelten. So ist z.B. zu jeder Zeit nur eine veränderbare Referenz auf eine Variable erlaubt. Es ist daher leicht nachvollziehbar welcher Programmabschnitt die Daten tatsächlich verändern kann. Race-Conditions in nebenläufigen Anwendungen sind somit ausgeschlossen. Rust bietet für solche Einsatzzwecke Messge Passing \cite{K1727} und threadsichere Referenzzähler \cite{ArcSrc} an. Die Regeln zu Ownership und Borrowing werden noch genauer vorgestellt.

\label{sec:kap3d2}
\subsection{Was ist Rust und warum sollte es verwendet werden?}
Rust ist eine statisch typisierte Programmiersprache, welche vor allem mit den Eigenschaften Performance, Verlässlichkeit und Produktivität eine Alternative zu anderen Sprachen anbieten soll \cite{RustPromises}. Die Version 1.0 wurde 2015 veröffentlich. Seither gibt es mit der ``Rust 2018 Edition'' und ``Rust 2021 Edition'' eine stetige Weiterentwicklung \cite{RustEditions}.

Die Performance begründet sich durch zwei wesentliche Aspekte. So werden alle Regeln die das Ownership und das Borrowing betreffen bereits zur Compilezeit durchgeführt. Ein zusätzlicher Overhead zur Laufzeit des Programms wird so vermieden. Der weitere Aspkekt ist die Implementierung von Features in Rust. So wird beispielsweise Monomorphisierung zur Compilezeit von Generics eingesetzt (vgl. \cite[S. 196 ff.]{SK19}). Für jeden implementierten Typen des Generics gibt es somit eine eigene Implementierung im Compilat. Hierdurch entfallen Typechecks wie sie z.B. in Java möglich sein können \cite{JavaGenerics}.

Die Verlässlichkeit beruht ebenfalls auf dem Ownership- und Borrowing-System. Hierdurch ist zu jeder Zeit klar, welche Variablen welche Daten enthalten. Ein unbeabsichtigtes Verändern der Daten oder Dangling References werden ebenfalls bereits zur Compilezeit ausgeschlossen. Dieses Prinzip funktioniert ebenfalls in nebenläufigen Anwendungen. Zudem stellt Rust sicher, dass man nicht außerhalb eines Puffers lesen oder schreiben kann. Dies kann aber unter Umständen zu einem Programmabbruch führen. Das spezielle \codeword{Option} \codeword{enum} bietet eine fehlerunanfällige Variante des \codeword{NULL}-Werts, das in Rust nicht existiert.

Um die Produktivität zu unterstützen bieten die beiden Tools \codeword{rustup} und \codeword{cargo} alles Notwendige, um den kompletten Entwicklungsprozess eines Rust-Programms zu erfüllen. Dies betrifft z.B. konkret eine Abhängigkeitsverwaltung, die Erstellung von Dokumentationen und das Ausführen von Tests und Benchmarks.

Wo nötig, setzt Rust auf etablierte Lösungen. So wird LLVM genutzt um ausführbare Programme zu erzeugen (vgl. \cite{RustcCodegen2} und \cite{RustcCodegen}).

\subsection{Grundlegendes}
\paragraph{Expression und Statements} Rust unterscheided bei Code-Anweisungen zwischen Statements und Expressions. Statements führen lediglich einen Codeblock aus, während Expressions stets einen Rückgabewert besitzen. Nahezu alle Sprachelemente in Rust sind als Expression implementiert (vgl. \cite[S. 122 ff.]{BO18}).

\begin{lstlisting}[language=rust, caption={Expression Einführendes Beispiel:}]
    let test_var = if bedingung_1 { false } else { true };
\end{lstlisting}

\paragraph{struct} Um eigene Datentypen zu definieren, werden \codeword{struct}s verwendet. Die Deklaration eines \codeword{struct} gibt Felder und Feldtypen an. Methoden und Funktionen werden erst nach der Deklaration hinzugefügt, wobei mehrere Implementierungsblöcke möglich sind. Die Implementierungen können Methoden inklusive einer Referenz auf die aktuelle Instanz oder Funktionen ohne entsprechende Referenz enthalten.

Dabei sollen \codeword{struct}s den Vorteil der Übersichtlichkeit und dieselbe Syntax wie \codeword{enum}s bieten (vgl. \cite[S. 91]{BO18}). Klassen gibt es in Rust nicht.

Das folgende Beispiel deklariert ein \codeword{struct} mit einem Feld. Anschließend wird ein Implementierungsblock angegeben, der jeweils eine Funktion und eine Methode enthält.

\begin{lstlisting}[language=rust, caption={struct}]
    struct MyStruct {
        my_field: i32,
    }

    impl MyStruct {
        fn new() -> MyStruct {
            MyStruct {
                my_field: 5,
            }
        }

        fn do_smth(&self) {}
    }
\end{lstlisting}
\paragraph{trait} In Rust gibt es weder Vererbung durch \codeword{struct}s, noch klassiche Interfaces. Mit \codeword{trait}s kann aber ein ähnliches Verhalten nachgebildet werden. Bei der Definition des \codeword{trait} findet die Deklarierung von Methoden und Funktionen statt. Anschließend können \codeword{struct}s und \codeword{enum}s ein oder mehrere \codeword{trait}s implementieren. Der Traitname wird schlussendlich z.B. in der Parameterdeklaration von Funktionen verwendet.

Für das bereits bestehende \codeword{struct} soll ein \codeword{trait} erstellt und implementiert werden.

\begin{lstlisting}[language=rust, caption={trait}]
    trait MyTrait {
        fn trait_method(&mut self) -> bool;
    }

    impl MyTrait for MyStruct {
        fn trait_method(&mut self) -> bool {
            true
        }
    }
\end{lstlisting}
\paragraph{match} Als Alternative zur \codeword{switch}-Anweisung bietet Rust \codeword{match}. Im Gegensatz zu anderen Sprachen muss bei \codeword{match} jeder mögliche Wert einer Variablen geprüft werden. Durch einen Variablennamen als letzter zu prüfender Wert wird dieser verallgemeinert. Alternativ kann der Wert unberücksichtigt gelassen werden.

Bei der Auswertung der Variablen ist es zudem erlaubt mehrere Werte gleichzeitig anzugeben. Da \codeword{match} ebenfalls als Expression umgesetzt ist, kann ein Rückgabewert wieder einer Variablen zugeordnet werden. Je nach Wert können verschiedene Aktionen ausgeführt werden.

\newpage

\begin{lstlisting}[language=rust, caption={match}]
    let mut var = 19;

    let match_var = match var {
        1 => {
            var = 5;
            String::from("klein")
        }
        2..=10 => String::from("bis 10"),
        11 | 13 | 17 => String::from("Primzahl"),
        i => i.to_string(),
        // _ => String::from("Nichts"),
    };
\end{lstlisting}

\subsection{Enums}
Der Aufzählungstyp \codeword{enum} spielt in Rust eine wichtige Rolle. So wird z.B. mit dem \codeword{enum} \codeword{Result} das Error-Handling in Rust ermöglicht. Weiterhin gibt es mit dem \codeword{Option} \codeword{enum}, wie bereits erwähnt, eine Alternative um fehlende \codeword{NULL}-Werte in Rust zu darzustellen.

Jede Ausprägung eines \codeword{enum} kann verschiedene Werte enthalten. Wie für \codeword{struct}s können Implementierungsblöcke definiert und Traits implementiert werden. Mit dem bereits vorgestellten \codeword{match} kann geprüft werden, welche Ausprägung das \codeword{enum} hat. Alternativ funktioniert dies auch mit der \codeword{if let}-Anweisung, die es erlaubt nur auf eine Ausprägung zu überprüfen.

In diesem Beispiel wird ein \codeword{enum} mit verschiedenen Werten definiert, die dann über eine \codeword{match}-Anweisung konkret abgefragt werden können. Zudem gibt es wieder einen Implementierungsblock für Fuktionen und Methoden. Außerdem wird ein \codeword{trait} implementiert. Die Syntax ist dabei identisch zu der Implementierung von \codeword{structs}.

\begin{lstlisting}[language=rust, caption={enum}]
    enum MyEnum {
        Entry1 { c: i32, m: i32, y: i32, k: i32 }, // Anonymes struct
        Entry2(i32, i32, i32), // 3 unbenannte Werte
        Entry3, // ohne Daten
    }

    let x = MyEnum::Entry2(42, 42, 42);
    match x {
        MyEnum::Entry2(v1, v2, v3) => { ... },
        _ => { ... }
    };

    impl MyEnum { ... }
    impl MyTrait for MyEnum { ... }
\end{lstlisting}

\subsection{Generics}
Rust bietet ebenfalls generische Typparameter an. Diese können bei \codeword{struct}, \codeword{enum}, \codeword{trait} und Funktionen verwendet werden. Um eine hohe Performance zu gewährleisten, wird Monomorphisierung zur Compilezeit eingesetzt (vgl. \cite[S. 196 ff.]{SK19}). Dies bedeutet, dass z.B. eine entsprechende Funktion speziell für die verwendeten Typen implementiert wird.

Dies wird exemplarisch für das bestehende \codeword{Option} \codeword{enum} veranschaulicht, welches im fertigen Programm zwei Mal mit unterschiedlichen Typen existiert.

\begin{lstlisting}[language=rust, caption={Veranschaulichung der Monomorphisierung \cite{MonoCodeEx}}]
    // enum im Quellcode
    enum Option<T> {
        Some(T),
        None,
    }

    let integer = Some(5);
    let float = Some(5.0);
    
    // enum nach Monomorphisierung
    enum Option_i32 {
        Some(i32), None,
    }
    enum Option_f64 {
        Some(f64), None,
    }
    fn main() {
        let integer = Option_i32::Some(5);
        let float = Option_f64::Some(5.0);
    }
\end{lstlisting}

Im Zusammenspiel mit \codeword{traits} kann ein entsprechender Typparameter begrenzt werden. Ein Nachteil der Monomorphie ist, dass ein Typparameter immer nur von einem konkreten Typ ersetzt werden kann. Eine Lösung hierfür bieten \codeword{trait objects}.

Im Folgenden Beispiel werden dazu ein \codeword{trait} und zwei \codeword{structs} definiert, die das \codeword{trait} implementieren. Das \codeword{ScreenTraitObject} kann im Vektor \codeword{components} beide Structs unabhängig voneinander vorhalten, da \codeword{trait objects} verwendet werden. \codeword{ScreenGeneric} benutzt allerdings nur einen einfachen Generic-Parameter für den Vektor, sodass tatsächlich nur eine konkrete Implementierung von \codeword{Draw} hinzugefügt werden kann.

\label{sec:BoxType}
Durch den \codeword{Box}-Typ werden die Werte auf dem Heap abgelegt, da nicht von vornherein klar ist, wie viel Speicher auf dem Stack benötigt wird.

\begin{lstlisting}[language=rust, caption={Trait Boundaries \cite{TraitBoundariesEx}}]
    trait Draw {}

    struct Button {}
    struct SelectBox {}

    impl Draw for Button {}
    impl Draw for SelectBox {}

    struct ScreenTraitObject {
        components: Vec<Box<dyn Draw>>,
    }
    `\newpage`
    // Bevorzugt, wenn nur wenige Typparemeter und/oder Einschränkungen
    struct ScreenGeneric<T: Draw> {
        components: Vec<T>,
    }
    // Oder falls mehrere Typparemeter und/oder Einschränkungen
    struct ScreenGeneric2<T, U>
    where
        T: Draw + Trait2 + Trait3,
        U: Trait4
    {}

    ScreenTraitObject {
        components: vec![
            Box::new(Button {}),
            Box::new(SelectBox {}),
        ],
    };

    ScreenGeneric {
        components: vec![
            Button {},
            SelectBox {}, // Fehler, da SelectBox != Button
        ],
    };
\end{lstlisting}

\subsection{Operatorenüberladung} In Rust können Operatoren überladen werden und für eigene als auch bestehende Typen implementiert und erweitert werden \cite{OperatorOverloading} \cite[S. 246 ff.]{BO18}. Diese Funktionlität kann im CAS dazu genutzt werden, um z.B. einen bestehenden Term ohne Funktionsaufruf zu verändern. Stattdessen können gewohnte Sprachmittel verwendet werden. Weiterhin ist es möglich, die Prüfung auf Gleichheit mit einem anderen Datentyp zu implementieren.

Im Beispiel kann das erstellte \codeword{enum} mit sich selbst addiert und mit dem primitiven Datentyp \codeword{i32} verglichen werden. Dabei werden die bereits existierenden Operatoren ``+'' und ``=='' verwendet.

\begin{lstlisting}[language=rust, caption={Operatorenüberladung}]
    enum Number {
        Int(i32),
        Float(f64),
    }

    impl std::ops::Add<Number> for Number {
        type Output = Number;

        fn add(self, rhs: Number) -> Number {
            match (self, rhs) {
                (Number::Int(v1), Number::Int(v2)) => Number::Int(v1 + v2),
                // Weitere Implementierung
            }
        }
    }

    let n1 = Number::Int(1);
    let n2 = Number::Int(2);
    let n3 = n1 + n2;

    impl PartialEq<i32> for Number {
        fn eq(&self, other: &i32) -> bool {
            match self {
                Number::Int(v) => v == other,
                _ => false,
            }
        }
    }

    if n3 == 3 { ... }
\end{lstlisting}

\subsection{Ownership, Borrowing und Lifetimes}
Im Folgenden sollen die Konzepte Ownership, Borrowing und Lifetimes vorgestellt werden. Diese tragen wesentlich zur erwähnten Speichersicherheit bei. Der Compiler beachtet die folgenden Regeln \cite{Rules1} \cite{Rules2}.

\begin{itemize}
    \item Jeder Wert ist einer Variablen zugewiesen, dem \codeword{Owner}
    \item Jeder Wert kann nur einen \codeword{Owner} besitzen
    \item Verlässt der \codeword{Owner} den Gültigkeitsbereich, wird die Variable ungültig und im Normalfall der Speicherplatz freigegeben
    \item Zu jeder Zeit kann es eine beliebige Anzahl an nicht veränderbaren Referenzen geben oder exakt eine veränderbare Referenz
    \item Referenzen müssen immer gültig (d.h. deklariert sein und der Owner muss mindestens denselben Gültigkeitsbereich wie die Referenz haben) sein
\end{itemize}

\label{sec:Ownership}
Das Ownership-Prinzip deckt dabei bereits die ersten drei Regeln ab. Zu jedem Zeitpunkt kann jeder Wert nur durch eine Variable angesprochen werden. Liegt der Wert auf dem Stack oder wird das \codeword{Copy}-Trait implementiert, wird bei einer Zuweisung der Wert kopiert \cite{CopyTraitOwner}. Liegt der Wert hingegen auf dem Heap, wie z.B. bei einem \codeword{Vector} oder einem \codeword{String}, wird das Ownership an die neue Variable übergeben.

\begin{lstlisting}[language=rust, caption={ownership}]
    let mut a = 2;
    let b = a;
    a = 4;
    println!("{}{}", a, b); // Ausgabe: 42
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s2); // Ok
    println!("{}", s1); // Fehler, Ownership wurde s2 übertragen
\end{lstlisting}

Um nicht ständig den Owner der Daten ändern zu müssen, z.B. bei einem Funktionsaufruf, werden mit dem Borrowing Referenzen erstellt. Hierauf beziehen sich die beiden letzten Regeln. Hierbei gilt außerdem, dass es nur veränderbare Referenzen geben kann, wenn der Owner veränderbar ist. Falls es eine veränderbare Referenz gibt, kann der Wert exklusiv durch diese verändert werden. Zur Referenzierung und Dereferenzierung kommen die \codeword{&}- und \codeword{*}-Operatoren zum Einsatz.

\begin{lstlisting}[language=rust, caption={borrowing}]
    // Nicht zulässig, da zwei mutable Referenzen
    let mut a = 5;
    let b = &mut a;
    let c = &mut a;
    *b = 1;

    // Nicht zulässig, da mutable und nicht mutable gemischt
    let mut a = 5;
    let b = &mut a;
    let c = &a;
    let d = &a;
    *b = 1;

    // Zulässig, da nur lesende Referenzen
    let a = 5;
    let b = &a;
    let c = &a;

    fn append_string(string1: &mut String, string2: &String) {
        string1.push_str(string2);
    } // Nur Referenzen verlassen den Gültigkeitsbereich, nicht die Owner!

    let mut s1 = String::from("Fern");
    let s2 = String::from("Uni");
    append_string(&mut s1, &s2);
    println!("{}", s1); // Ausgabe: FernUni
\end{lstlisting}

Schlussendlich verhindern Lifetimes, dass die Referenzen für das Borrowing ungültig werden, und die Variable - und somit der Wert - vor den Referenzen freigegeben wird. Die Illustrierung der Lifetimes enstpricht dabei den Codeblöcken, in denen die Variablen definiert sind. Die inneren Lifetimes im Beispiel könnten jedoch auch Funktionsaufrufe sein. Das erste Beispiel ist ungültig, da die Lifetime des Wertes kleiner ist, als die Referenz, die darauf zeigen soll.

Das zweite Beispiel ist im Gegensatz dazu gültig, weil der eigentliche Wert erst nach der Referenz freigegeben wird.

\newpage

\begin{lstlisting}[language=rust, caption={Lifetime Veranschaulichung \cite{LifetimeEx}}]
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+

    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                         // ----------+
\end{lstlisting}

In den meisten Fällen kann der Compiler die Lifetimes von Variablen und Referenzen selbst bestimmen. Eine explizite Deklarierung der Lifetimes ist nötig, wenn beispielsweise eine Funktion mehr als eine Referenz entgegennimmt und wieder zurückgibt. Dies soll am folgendem Beispiel verdeutlicht werden. Die Lifetimedeklarierung \codeword{'a} gibt an, dass sowohl die beiden Auswahlmöglichkeiten als auch der Rückgabewert diesselbe Lifetime besitzen müssen. Während dies bei der ersten Zuweisung erfüllt ist, wird eine Auswahlmöglichkeit bei der zweiten Zuweisung erst in einer inneren Lifetime deklariert. Dies stimmt nicht mit der Lifetime des Rückgabewerts überein.

\begin{lstlisting}[language=rust, caption={Lifetime Beispiele \cite{RustLifetimeEx}}]
    fn main() {
        // Funktioniert, da Werte dieselbe Lifetime wie Rückgabewert haben
        let mult1 = 1;
        let mult2 = 2;
        let multiplikator = {
            let zaehler: i32 = 3;
            multiplikator_waehlen(&mult1, &mult2, &zaehler)
        };

        // Funktioniert nicht, da mult2 vor multiplikator freigegeben wird
        let mult1 = 1;
        let multiplikator = {
            let mult2 = 2;
            let zaehler: i32 = 3;
            multiplikator_waehlen(&mult1, &mult2, &zaehler)
        };
    }
    `\newpage`
    fn multiplikator_waehlen<'a, 'b>(
        mult1: &'a i32,
        mult2: &'a i32,
        decision_maker: &'b i32,
    ) -> &'a i32 {
        if *decision_maker < 5 {
            mult1
        } else {
            mult2
        }
    }
\end{lstlisting}

\subsection{Stack und Heap}
Beide Speicherbereiche müssen in Rust seperat betrachtet werden. Datentypen, die eine bekannte Größe haben, wie z.B. eine Ganzzahl, werden in Rust auf dem Stack nach dem Prinzip ``last in, first out'' abgelegt. Hierdurch hat der Stack eine bekannte Größe. Durch diese Einschränkung kann der Zugriff auf den Stack zügig erfolgen. Typen deren Größe zur Compilezeit nicht bekannt sind, z.B. ein Vektor, müssen in Rust auf dem Heap abgelegt werden. Da für diese Daten erst ein passender Bereich in der benötigten Größe gesucht werden muss, ist der schreibende Zugriff langsamer auf dem Stack. Auch der lesende Zugriff erfolgt über eine Referenz, sodass dieser mehr Zeit in Anspruch nimmt \cite{StackHeap} \cite[S. 233 ff.]{SK19}. 

Besonders wichtig ist dieser Unterschied, wenn eine Variable freigegeben wird. Liegt der Wert auf dem Stack, muss nur dieser freigegeben werden. Liegt der Wert hingegen auf dem Heap, muss sowohl der Heap, als auch die Referenz auf dem Stack freigegeben werden.

\subsection{Copy und Clone}
Rust bietet zwei Möglichkeiten Werte zu duplizieren. \codeword{Copy} ist dabei möglich, wenn der Wert nur auf dem Stack liegt. Die Zuweisung ``a = b;'' kopiert den Wert b. Sowohl ``a'' als auch ``b'' haben ein eigenes Ownership. Die Funktionsweise ähnelt \codeword{memcpy} in C \cite[S. 259 ff.]{SK19}.

Liegen die Werte hingegen auf dem Heap, muss die \codeword{clone}-Methode für den Typen implementiert werden. Hierdurch ist die Kopie explizit und kopiert standardmäßig ebenfalls die Daten auf dem Heap. Durch das Anpassen der Methode können z.B. auch nur die Stackwerte kopiert und ein Referenzzähler implementiert werden. Die \codeword{clone}-Methode erlaubt somit flexible Strukturen \cite[S. 260 ff.]{SK19}. Bei einer Zuweisung wird ansonsten \hyperref[sec:Ownership]{wie bereits gezeigt} das Ownership abgegeben.

\newpage

\section{Implementierung des CAS}
Das folgende Kapitel stellt die Implementierung des CAS in den Vordergrund. Hierzu sollen auch Überlegungen zu früh auftretenden Problemen gemacht werden.

\subsection{Überlauf und Ungenauigkeit}
Ein bereits zu Beginn auftretendes Problem für das CAS ist der Umang von Ganzzahlüberläufen und die Ungenaugikeiten der Rechnung mit Fließkommazahlen \cite{IEEE754}. So gibt das folgende Programm in Rust einen falschen Wert für die Addition aus und bricht anschließend ab.

\begin{lstlisting}[language=rust, caption={Überlauf und Ungenauigkeit}]
    let f1 = 0.1;
    let f2 = 0.2;
    println!("{}", f1 + f2);

    let mut x = i32::MAX;
    x += 1;
    println!("{}", x);

    // Ausgabe
    0.30000000000000004
    thread main panicked...
\end{lstlisting}

Ein Blick zu SymPy zeigt, dass Lösungen direkt aus Python verwendet werden können, die in Rust nicht existieren. So besitzen Ganzzahltypen bereits eine beliebige Präzision \cite{PythonDocuIntPrecision}. Für Fließkommazahlen ist die Klasse \codeword{Float} implementiert, die eine ungebrenzte Genauigkeit erlaubt. Dabei kann mit dem zweiten Parameter die eigentliche Präzision bestimmt werden. Es wird darüber hinaus angeraten den eigentlichen Wert als String zu übergeben, da der native \codeword{float}-Typ in Python eine Ungenauigkeit hervorrufen kann \cite{SymPyFloat}.

\begin{lstlisting}[language=Python, caption={SymPy Präzision}]
    x = 12345678901234567890...
    print(type(x))
    // <class int>

    print(sympy.Float('0.1', 100) + sympy.Float('0.2', 100))
    // 0.300000000000000000000000000000000000000000000...

    print(float(0.1) + float(0.2))
    // 0.30000000000000004
\end{lstlisting}

In ``Modern Computer Algebra'' \cite[S. 29 ff.]{Gathen2013} und ``Computer Algebra - Concepts and Techniques'' \cite[S. 81 ff.]{Lamagna2019} sind theoretische Implementierungen für Ganzzahlwerte angegeben. Hiervon könnte in dieser Arbeit Gebrauch gemacht werden und diese Typen selbst implementiert und für Fließkommazahlen erweitert werden. Allerdings existieren bereits die beiden Crates (Abhängigkeiten im Rust-Ökosystem) ``num'' \cite{CrateNum} und ``bigdecimal'' \cite{CrateBigdecimal}, welche Typen mit ungebrenzter Präszision anbieten.

Folgend soll die Performance zwischen den primitiven Typen auf dem Stack, den primitiven Typen auf dem Heap und den Crates verglichen werden. Wie zu erwarten ist die Speicherung auf dem Stack am effizientesten, der Zugriff auf dem Heap kostet Zeit. Der zusätzliche Zeitverlust bei den Crates lässt sich zum einen dadurch erklären, dass immer ein Überlauf geprüft werden muss, um den Wert richtig zu verarbeiten, andererseits verwendet der Typ \codeword{BigInt} einen Vektor. Wie in \hyperref[sec:kap3d2]{Kapitel 3.2} bereits erwähnt, wird bei einem Zugriff zusätzlich geprüft, ob der Index gültig ist, dies kostet ebenfalls Zeit.

Im Benchmark werden Zahlen von 10 bis 9999 durchlaufen und in jedem Durchlauf eine Berechnung mit dem vorher existierenden Wert durchgeführt.

\begin{lstlisting}[language=rust, caption={Benchmark Primitive Typen Stack Ganzzahl}]
    let mut x: i64 = 0;
    for i in 10..10000 {
        x += i;
        x /= 3;
    }
    assert_eq!(x, 4999);
\end{lstlisting}

\begin{table}[ht!]
    \caption{Ergebnisse Benchmark Rust-Typen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Test} & \textbf{Zeit Median in ns} & \textbf{\makecell{Unterschied min. und max. Laufzeit \\ in ns}} \\
        \hline
        Primitiv int & 18.505 & 396 \\
        \hline
        Primitiv int Heap & 50.293 & 1.683 \\
        \hline
        Primitiv float & 36.975 & 809 \\
        \hline
        Primitiv float Heap & 74.324 & 920 \\
        \hline
        num Crate & 548.640 & 42.989 \\
        \hline
        bigdecimal Crate & 7.447.000 & 474.681 \\
        \hline
    \end{tabular}
\end{table}

Bisher ist es mit Rust-Benchmarks noch nicht möglich den Speicherverbrauch zu messen. Allerdings kann dieser für die gewählten Beispiele auch selbst gut bestimmt werden. Hierbei geht es lediglich um die eigentlichen Werte, mit welchen Berechnungen durchgeführt werden.

\paragraph{Primitive Typen Stack} Die Datentypen \codeword{i64} und \codeword{f64} verbrauchen 8 Bytes. Es werden somit nie mehr als $8*4=32$ Bytes für die eigentlichen Daten benötigt. Die Variable $x$, die das Ergebnis enthält, beansprucht davon 8 Bytes. Der Schleifenparameter $i$ wird ebenfalls als \codeword{i64} (bzw. \codeword{i32} im Falle der Benchmarks mit \codeword{f64}) behandelt durch die Addition mit $x$ (bzw. dem TypeCasting) und verbraucht ebenfalls 8 Bytes. Bei der Addition $x+i$ wird, wie bereits erwähnt, bei einem Funktionsaufruf eine Kopie der Werte erstellt, die den Copy-Trait implementieren. Die Typen \codeword{i64} und \codeword{f64} implementieren den Copy-Trait \cite{Rusti64Copy} und somit wird sowohl von $x$ als auch von $i$ zur Addition eine Kopie erzeugt.

\paragraph{Primitive Typen Heap} Der Speicherverbrauch der eigentlichen Werte ist wie bei den primitiven Typen auf dem Stack. Davon entfallen 8 Bytes auf dem Heap statt auf dem Stack. Zur Berechnung müssen die \codeword{Box}-Werte dereferenziert werden. Zusätzlich befindet sich ein Zeiger auf dem Stack durch \codeword{Box}. Die Größe hängt von der verwendeten Architektur ab \cite{BoxExmaple}.

\paragraph{num und bigdecimal} Der Datentyp BigInt verwendet einerseits ein Vorzeichen, welches 1 Byte verbraucht \cite{EnumSize}, als auch den Datentyp BigUint, der wiederum einen Vektor mit BigDigit erhält. Das Vorzeichen ist als \codeword{Enum} umgesetzt \cite{BigIntSign}. Betrachtet man diese Definition genauer, kann dieser Typ zwischen 4 Bytes (u32) und 16 Bytes (i128) verbrauchen (Quelle). Während des Debuggens auf verschiedenen Systemen wird in diesem Beispiel der Typ u64 angenommen und somit ein Speicherplatz von 8 Bytes benötigt. Mit größer werdenden Zahlen steigt jedoch dieser Verbrauch, da sich der Vektor vergrößert. Zudem liegen nicht mehr alle Daten auf dem Stack, sondern alle BigDigits auf dem Heap, was die Zugriffsgeschwindigkeit zusätzlich erhöht. (Quelle)

Der Typ bigdecimal verwendet laut Beschreibung den Typ BigInt (Quelle) und zusätzlich einen 64-Bit-Integer um die Position der Dezimalstelle zu bestimmen \cite{CrateBigdecimalDocs}. Dadurch erhöht sich der Speicherverbrauch nur unwesentlich.

\paragraph{Entscheidung der verwendeten Typen} Im Rahmen dieser Arbeit ist eine eigene Implementierung der Typen für beliebige Präzision nicht das Ziel. Genausogut können auch die bereits bestehenden Crates verwendet werden. Da dadurch aber die Performance leidet, wenn auch wahrscheinlich nicht relevant für spätere Beispiele und Tests, ist wiederrum die Implementierung mit primitiven Typen von Vorteil.

Da Rust Generics untersützt, wurde die Entscheidung getroffen, das CAS in Teilen mit Generics umzusetzen, sodass beide Kombinationen verwendet werden können. Dabei sollen alle Funktionen des Systems mit den primitiven Typen funktionieren und einige Beispielimplementierungen mit den Crate-Typen gemacht werden. Dies erlaubt sowohl eine spätere Erweiterung der Crate-Typen als auch die Entwicklung der eigenen Typen.

\subsection{Grundlegende Datenstruktur}
Ein erster Ansatz die Datenstrukturen darzustellen war ein binärer Baum, dessen Knoten die Operanden und die Blätter einzelne Werte sind. Dies entspricht dem abstrakten Syntaxbaum nach dem Parsen. Für den Term $x+1+2$ ergibt sich folgender Baum.

\Tree[.+
        [.+
                [.x ]
                [.1 ]
        ]
        [.2 ]
    ]

In Rust sieht die Implementierung folgendermaßen aus. Die Ausprägung Add benötigt für die Werte immer die Struktur \codeword{Box}, die die Daten auf den Heap speichert. Zur Compilezeit lässt sich die Größe auf dem Stack nicht bestimmen, da unklar ist, wie viele Ebenen Add beinhaltet \cite{RustRecursiveTypes}.

\begin{lstlisting}[language=rust, caption={BTree Ast}]
    enum BTree {
        Number(i64),
        Symbol(String),
        Add(Box<BTree>, Box<BTree>),
    }

    let tree = BTree::Add(
        Box::new(BTree::Add(
            Box::new(BTree::Symbol("x".to_owned())),
            Box::new(BTree::Number(1)),
        )),
        Box::new(BTree::Number(2)),
    );
\end{lstlisting}

Bei der direkten Änderung bzw. Zusammenfassung des Baums ergibt sich durch das Ownership ein Problem. Man benötigt auf jeden Knoten und Blatt eine veränderbare Referenz. In diesem Beispiel würden im einfachsten Fall das untere \codeword{BTree::Add} durch \codeword{BTree::Symbol} ersetzt und das rechte \codeword{BTree::Number} aktualisiert werden.

Würde versucht werden die Referenzen in einem Vektor zu speichern, ist das zumindest bereits für \codeword{Add} nicht möglich. Da \codeword{Box} das Ownership des Wertes in Anspruch nimmt, kann dazu parallel keine veränderbare Referenz existieren. Dasselbe Problem tritt auf, wenn die Blätter bereits der entsprechende \codeword{Box}-Wert sind, dann würde das Ownership weiterhin an \codeword{parent_1} übergeben werden.

\begin{lstlisting}[language=rust, caption={get refs}]
    let mut leave_1 = BTree::Number(1);
    let mut leave_2 = BTree::Number(2);
    let mut parent_1 = BTree::Add(Box::new(leave_1), Box::new(leave_2));

    let mut refs = vec![&mut parent_1, &mut leave_1, &mut leave_2];
    println!("{:?}", refs);
\end{lstlisting}

Hier könnte nun versucht werden, das Problem mit Referenzzählern (vgl. \cite{RcSrc} und \cite[S. 293 ff.]{SK19}) zu lösen, die dafür gedacht sind, mehrere Referenzen zu erzeugen. In Kombination mit anderen Strukturen in Rust können diese Referenzen auch veränderbar sein (vgl. \cite{CellSrc}, \cite{RefCellSrc} und \cite[S. 299 ff.]{SK19}).

Ebenfalls möglich wäre die Nutzung von Rohzeigern in Verbindung mit \codeword{unsafe}, was Code in Rust kennzeichnet, der auf undefinierten Speicherbereich zeigen kann \cite{RustUnsafe}.

Da beide Varianten aber sich entweder auf den Codeumfang und -verständlichkeit auswirken oder der Hauptgrund Rust zu benutzen umgangen wird, soll, wenn möglich auf diese Varianten verzichtet werden. Damit ausgeschlossen ist aber auch die Möglichkeit den Baum in situ zu verändern

Eine Alternative wäre lediglich lesende Referenzen zu erzeugen, über diese zu iterieren und dann einen neuen Baum zu erstellen. Wenn aber sowieso alle Werte benötigt werden, um diese zusammenfassen zu können, könnten diese auch in in einem Vektor gespeichert werden. Für die Addition und Multiplikation würde dann der Baum für den Term $myfunc(a, b*c)+1+2+x*y*2^z$ beispielsweise wie folgt aussehen:

\Tree[.+-Vektor
        [.func
            [.``myfunc'' ]
            [.Parameter-Vektor
                [.a ]
                [.*-Vektor
                    [.b ]
                    [.c ]
                ]
            ]
        ]
        [.1 ]
        [.2 ]
        [.*-Vektor
            [.x ]
            [.y ]
            [.pow
                [.2 ]
                [.z ]
            ]
        ]
    ]

Werden die Bedingungen und Vereinfachungen noch angewendet, so ergibt sich für den Term $a-(1+b)+3/5$ der Baum:

\Tree[.+
        [.a ]
        [.-1 ]
        [.*
            [.-1 ]
            [.b ]
        ]
        [.Rational
            [.3 ]
            [.5 ]
        ]
    ]

Eine ähnliche Struktur findet sich ebenfalls in ``SymbolicC++'' \cite[S. 284 ff.]{Tan2000}. SymPy verwendet ebenfalls diese Struktur \cite{SymPyTreeStruct}. Da sich dieser Aufbau anscheinend für ein CAS eignet, soll dieser auch in diesem System verwendet werden. Hierrauf bauen alle weiteren Operationen auf, wie z.B. das Zusammenfassen des Terms oder Substitution.

\subsection{Grundtypen des CAS}
In diesem Kapitel soll definiert werden, welche \codeword{structs}, \codeword{traits} oder \codeword{enums} benötigt werden, um das CAS zu erstellen. Darüber hinaus soll grob umrissen werden, welche Implementierungen im weiteren Verlauf sinnvoll sein können und welchen Zweck diese erfüllen.
Weiterhin noch zu erwähnen, dass hier nicht definiert werden soll, welche \codeword{Derive macros} diese Typen erhalten. In Rust ist es üblich \codeword{structs} und \codeword{enums} mit diesen Makros zu erweitern, um z.B. anzugeben, dass der Typ kopiert oder sortiert werden kann. Die Implementierung dieser Funktionalität wird dann teilweise zur Compilezeit vom Makro übernommen.

\label{sec:NumTypes}
\paragraph{enum PrimNum und enum PrecisionNum} Diese beiden \codeword{enums} sollen als Implementierung für den Generic-Parameter im CAS dienen. Ebenso bieten diese den Vorteil, dass später ein allgemeiner Nummern-Typ existiert, mit welchem gerechnet werden kann und nicht ständig manuell Type Castings durchgeführt werden müssen. So ist es in Rust nicht möglich eine Addition oder Multiplikation von \codeword{i32} und \codeword{f64} durchzuführen. Hierzu muss einer der beiden Werte erst in den anderen manuell überführt werden.

Ein weiterer Vorteil ist, dass direkt eine rationale Ausprägung des \codeword{enum} implementiert werden kann. Auch hier kann der Typ direkt die Rechnung übernehmen. Hierzu werden die Operatoren \codeword{std::ops::Add} und \codeword{std::ops::Mul} für das Enum selbst überladen. Im Hinblick auf die Bedingung, dass eine Subtraktion eine Addition ist, wird ebenso \codeword{std::ops::Mul} für einen Ganzzahlwert mit den Enums überladen. Ebenso kann es von Interesse sein, ob es sich um das neutrale Element der Addition oder Multiplikation handelt, um einen Term zu vereinfachen. Für diesen Fall wird der Trait \codeword{PartialEq} für Ganzzahlen überladen, um hier nach Bedarf auch andere Werte zu überprüfen. Eine Alternative wären Methoden, die einen \codeword{bool}-Wert zurückgeben, ob es sich um einen solchen Wert handelt.

In der vorliegenden Implementierung wird \codeword{PrimNum} solange wie möglich mit Ganzzahlen und rationalen Werten arbeiten. Sobald ein Fließkommawert addiert wird, werden die beiden anderen Werte zu einer Fließkommazahl umgewandelt. Dies geht zulasten der Genauigkeit und könnte bei Bedarf so angepasst werden, dass eine rationale Zahl erzeugt wird. Zudem wäre denkbar, Fließkommazahlen und andere numerische Typen nicht standardmäßig zusammenzufassen.

\paragraph{trait NumberType} Dieser Trait soll hauptsächlich als Typparameter oder als Einschränkung für Generics zum Einsatz kommen. Wie bereits erwähnt, soll ein Teil des CAS mit verschiedenen Typen nutzbar sein. In diesem Fall sind dies die beiden \codeword{enums}, welche gerade erwähnt worden sind. Zudem werden Funktionen als Bedingung definiert, um die neutralen Elemente der Addition und der Multiplikation zurückzugeben sowie die Möglichkeit einen Bruch zu kürzen. Diese müssen dann von den \codeword{enums} implementiert werden.

Außerdem kann dieser Trait bereits weitere Bedingungen aufnehmen, wie z.B. dass der implementierende Enum gewisse Operatorenüberladungen besitzen muss oder auch, dass die Werte vergleichbar und sortierbar sind.

\paragraph{struct Parser} Auch wenn angedacht ist, eine bestehende Bibliothek zur lexikalischen Analyse von Strings einzusetzen, wird ein Parser benötigt, der die generierten Tokens oder die entstehende Datenstruktur in die Struktur des Systems überführt.

\subsection{Datenstruktur in Rust}
Mit dem Wissen über Generics und und den theoretischen Überlegungen zur Datenstruktur, kann diese in Rust folgendermaßen umgesetzt werden:
\begin{lstlisting}[language=rust, caption={Datenstruktur in Rust}]
    pub enum Ast<N> {
        Add(Vec<Ast<N>>),
        Mul(Vec<Ast<N>>),
        Pow(Box<Ast<N>>, Box<Ast<N>>),
        Symbol(String),
        Const(String),
        Func(String, Vec<Ast<N>>),
        Num(N),
    }
\end{lstlisting}

\paragraph{Add und Mul} Diese beiden Ausprägungen besitzen als Wert einen Vektor, der weitere Elemente enthält. So sind diese einfach abrufbar und der Vektor kann gezielt geändert werden, z.B. zum Sortieren der Werte oder das Entfernen von unnötigen Elementen (neutrale Elemente der Addition oder Multiplikation).

\paragraph{Pow} Diese Ausprägung besitzt zwei Parameter, Basis und Exponent, die jeweils wieder beliebige Ausdrücke sein können.

\paragraph{Symbol} Ein einfacher String, der einen Variablennamen enthält. Diese sollen später einfach substituiert werden können.

\paragraph{Const} Ein einfacher String, der einen Konstantennamen enthält. Hierbei ist die Nutzung von UTF-8 möglich, z.B. $\pi$. Eigens hinzugefügte Funktionen können somit prüfen, um welche Konstante es sich handelt und entsprechend eine Vereinfachung implementieren. Es besteht darüber hinaus die Möglichkeit Konstanten als Wert zurückzugeben.

\paragraph{Func} Diese Ausprägung besitzt ebenfalls zwei Parameter, den Namen der Funktion und die übergebenen Parameter als Vektor. Der Name kann somit einfach ausgewertet und die Parameter einfach übergeben werden.

\paragraph{Num} Diese Ausprägung enthält als Wert eine Variante, die das \codeword{trait} \codeword{NumberType} implementiert.

\paragraph{Auswertung des Terms} Eine Hauptfunktionalität, die dieses Enum erhält, ist die Möglichkeit einen Term zusammenzufassen und falls möglich soweit wie möglich in ein numerisches Ergebnis zu überführen. Dabei muss einerseits die Ausführungsreihenfolge beachtet werden, andererseits soll diese Methode leicht erweiterbar sein.

Im vorliegendem System wird die Methode rekursiv implementiert. Eine iterative Lösung wäre ebenfalls möglich. Aufgrund des Ownership und Borrowing in Rust wäre solch eine Lösung aber komplex, weniger leserlich und unverständlich \cite{RustRecToItAst}.

Bei der entsprechenden Auswertung einer Ausprägung des \codeword{Ast} werden dabei erst alle ``Kindelemente'' ausgewertet. Für die Addition bedeutet dies konkret, dass erst alle Elemente im Vektor ausgewertet werden und danach erst versucht wird zu addieren. Für Potenzen werden entsprechend erst Basis und Exponent ausgewertet.

Eine erste Implementierung erfolgt folgendermaßen. Die beiden zusätzlichen Parameter \codeword{evaler} und \codeword{hard_eval} werden noch näher in den Kapiteln zu ``\hyperref[sec:kapErRustUndBei]{Erweiterbarkeit in Rust und Beispiele}'' und ``\hyperref[sec:ungenauigkeitenKapitel]{Ungenauigkeiten erlauben}'' näher erläuert.

Bei der Entscheidung, ob das Element direkt bearbeitet wird oder ein neuer \codeword{Ast} zurückgegeben wird, wurde der Definition von SymPy gefolgt, sodass der originale Term nicht verändert sondern ein neuer erstellt wird.

\begin{quote}
    ``SymPy expressions are immutable. No function will change them in-place.'' \cite{SymPySubs}
\end{quote}

Mit den bereits genannten Einschränkungen, ergibt sich, dass die \codeword{clone}-Methode aufgerufen werden muss, da einige Daten auf dem Heap abgelegt werden. Bei einer Zuweisung oder einem Rückgabewert würde ansonsten der originale \codeword{Ast} das Ownership abgeben. Der \codeword{Copy}-Trait kann für \codeword{Ast} nicht implementiert werden, da bereits Vektoren diesen Trait nicht implementieren.

\begin{lstlisting}[language=rust, caption={eval-Methode 1. Implementierung}]
    pub fn eval(
        &self,
        evaler: &EvalFn<N>,
        hard_eval: &bool,
    ) -> Ast<N> {
        match self {
            Ast::Add(vec) => add(
                vec.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Mul(vec) => mul(
                vec.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Pow(base, exp) => pow(
                base.eval(evaler, hard_eval),
                exp.eval(evaler, hard_eval),
                evaler,
                hard_eval,
            ),
            Ast::Func(name, args) => func(
                name,
                args.iter()
                    .map(|t| t.eval(evaler, hard_eval))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Const(name) if *hard_eval => {
                if evaler.consts.contains_key(name) {
                    evaler.consts[name]()
                } else {
                    self.clone()
                }
            }
            _ => self.clone(),
        }
    }
\end{lstlisting}

\paragraph{Allgemeine Anmerkungen} Der Generic-Typparameter \codeword{N} soll den gewählten Nummerntyp darstellen. Dieser wird aber noch nicht eingeschränkt, da sonst diese Einschränkungen später für alle implementierenden Blöcke gelten müssen. Dies kann z.B. nicht gewünscht sein, wenn eine grundlegend andere Art implementiert werden soll, um Terme zu verarbeiten, bei der der Trait \codeword{NumberType} keine Verwendung finden soll. Mit diesem Ansatz kann auch die definierte Ausführungsreihenfolge der Ausprägungen bestimmt werden. Bevor also \codeword{Ast::Add} ausgewertet wird, werden zuerst alle Elemente des Vektors ausgewertet. Eventuelle Vereinfachungen sind dann bereits vorgenommen.

\paragraph{Datenstruktur auf dem Speicher} Mit dieser Implementierung werden nahezu alle Daten auf dem Heap abgelegt. Einzig die Variante \codeword{Ast::Num<PrimNum>} kann komplett auf dem Stack abgelegt werden, da diese eine definierte Größe hat. String und Vec speichern die Daten auf dem Heap und halten nur einen Zeiger auf dem Stack, falls es das oberste Element ist. Box legt die Daten wie bereits im Kapitel 3.5 zu \hyperref[sec:BoxType]{Trait Boundaries} gezeigt, aus Gründen der ungewissen Speicheranforderung auf dem Heap ab. Lediglich der Zeiger kann sich auf dem Stack befinden.

Zwei konkrete Beispiele sollen dies veranschaulichen. Der String bei \codeword{Symbol(x)} wird intern als Vektor mit dem Typ \codeword{u8} repräsentiert \cite{StringSrc}.
\begin{lstlisting}[language=rust, caption={Term 1 Stack und Heap}]
    let term = Ast::Num(PrimNum::Int(42));
    Stack:
    Ast::Num
    +---------------+
    |  PrimNum::Int |
    |  +------+     |
    |  |  42  |     |
    |  +------+     |
    +---------------+
\end{lstlisting}

\newpage

\begin{lstlisting}[language=rust, caption={Term 2 Stack und Heap}]
    let term = Ast::Add(vec![
        Ast::Num(PrimNum::Int(1337)),
        Ast::Symbol("x".to_owned()),
        Ast::Mul(vec![
            Ast::Num(PrimNum::Float(1.1)),
            Ast::Pow(
                Box::new(Ast::Num(PrimNum::Int(2))),
                Box::new(Ast::Num(PrimNum::Int(2))),
            ),
        ]),
    ]);
    Stack:
    Add(Vec) (Beispielhaft, es fehlt z.B. noch die capacity)
    +-------+-------+
    |  ptr  |  len  |
    +---|---+-------+
        v
    Heap:
    Num(Int)  Symbol(Vec<u8>)  Mul(Vec)
    +-------- +----------------+---------------+
    |  1337   |  ptr  |  len   |  ptr  |  len  |
    +---------+---|------------+---|-----------+
                  v                v
              +-------+     Num(Float)  Pow
              |  120  |     +-----------+---------------+
              +-------+     |  1.1      |  ptr  |  ptr  |
                            +-----------+---|-------|---+
                                            v       v
                                        Num(Int)  Num(Int)
                                        +--------+--------+
                                        |  2     |  2     |
                                        +--------+--------+
\end{lstlisting}

\newpage

\section{Parser für mathematische Ausdrücke}
Ziel dieses Kapitels ist die Nutzung bzw. Implementierung der lexikalischen Analyse bzw. eines Parsers, um Terme in das Enum \codeword{Ast} zu überführen. Erst hier sollen Vereinfachungen und Zusammenfassungen gemacht werden. 
\subsection{Prüfung von bestehenden Bibliotheken zum Parsen}
\paragraph{mexprp Rust} \cite{CrateMexprp} Diese Bibliothek wurde geprüft, da einerseits beim Parsen eine beliebige Genauigkeit möglich ist. Andererseits schien nach einem kurzen Blick in den Code es auch möglich den Term einfach in die gewünschte Form zu bringen, da das Enum \codeword{Term} einen Abstract Syntax Tree implementiert anfänglich angedacht. Über diesen müsste nur einmal iteriert werden, um zu unserer modifizierten Version zu gelangen.

Die Abhängigkeit ``rug'' soll die beliebige Genauigkeit ermöglichen. Dabei handelt sich um ein Interface zu den GNU-Bibliotheken GMP, MPFR, MPC. Für diese müssen aber unter GNU/Linux, macOs und Windows jeweils andere Abhängigkeiten installiert werden. Ein schnelles Testen auf anderen Rechnern ist somit ausgeschlossen. Aus diesem Grund wird diese Bibliothek nicht verwendet. Ebenso wird deshalb ``rug'' nicht als Bibliothek für die beliebige Genaugikeit verwendet, sondern num und bigdecimal.

\paragraph{meval Rust} \cite{CrateMeval} Diese Bibliothek erscheint recht unkompliziert und einfach in der Nutzung. Die geparsten Tokens werden als UPN (umgekehrte polnische Notation) ausgewertet. Dies könnte man prinzipiell dazu nutzen, den modifizierten Ast zu erzeugen. Ein kleiner Nachteil ist, dass nur Fließkommazahlen ausgewertet werden. Sollte der Lexer erweitert werden, sodass eine beliebige Genauigkeit erreicht werden soll, müsste dieser Part neu geschrieben werden. Zudem wurde diese Bibliothek leider nicht bei der initialen Recherche in Betracht gezogen und nicht weiter überprüft. Während der Entwicklung des CAS wurde interessehalber vertiefend reingesehen und die Enums \codeword{Operator} und \codeword{Token} größtenteils übernommen. Wäre der Lexer nicht bereits zu einem großen Teil implementiert, würde die Möglichkeit genutzt, die Tokens aus dieser Bibliothek zu erzeugen.

\paragraph{evalexpr Rust} \cite{CrateEvalexpr} Diese Bibliothek erscheint sehr umfangreich. Allerdings lässt sich fast nur die \codeword{eval}-Funktion nutzen, da fast alle anderen Strukturen nicht mit dem Schlüsselwort \codeword{pub} versehen sind. Es war daher nicht möglich, den Tokenizer bzw. den Baum direkt zu nutzen, in dem sich ein bereits geparster String befindet. Daher kam eine Nutzung dieser Bibliothek nicht in Betracht.

\paragraph{tinyexpr C} \cite{CTinyexpr} Da es in Rust auch möglich ist, bereits bestehenden C-Code zu nutzen, wurde ebenfalls geprüft eine einfache C-Bibliothek zu nutzen, sodass auch das die notwendige Schnittstelle des Parsers nicht zu komplex wird. Hierbei wurde tinyexpr näher betrachtet. Allerdings müssen Variablen bereits vor der lexikalischen Analyse zumindest bekannt sein \cite{CTinyexprReadme}. Da sich generell gegen diesen Schritt entschieden wurde, wurde auch diese Bibliothek nicht verwendet.

\paragraph{Fazit} Eine geeignete Bibliothek zu finden, die den Anwendungszweck erfüllt und dabei nicht zu weit weg vom eigentlich Ziel ist, war nicht möglich. Daher wurde sowohl die lexikalische Analyse als auch das Parsing selbst implementiert. Die wichtigsten Eigenschaften hierzu wurden aus dem Kurs 01810 Übersetzerbau herausgearbeitet, den ich im Wintersemester 17/18 belegte.

\subsection{Implementierung der lexikalischen Analyse bzw. Tokenizer} In diesem Schritt soll aus einer übergebenen Zeichenkette ein Vektor mit Tokens erstellt werden. Hierbei wird zeichenweise gearbeitet und nicht über reguläre Ausdrücke. Eine Besonderheit in Rust ist, dass ein Char in einem String nicht über einen Index referenziert werden kann. Da Strings als UTF-8 gespeichert werden, ist mit dem Index nicht eindeutig, ob das entsprechende Byte oder Zeichen angesprochen werden soll. Daher muss der String erst in einen Vektor des Typ \codeword{Char} umgewandelt werden.

Die Tokens werden dabei als Enum implementiert. In diesem Abschnitt wird auf die Implementierung von Generics verzichtet und nur der Typ \codeword{PrimNum} erlaubt.

Im Enum werden folgende Werte benötigt:
\begin{lstlisting}[language=rust, caption={Enum Token}]
pub enum Token {
    LParen,
    RParen,
    Comma,
    Var(String),
    Func(String),
    Op(Operator),
    Num(PrimNum),
}
\end{lstlisting}

\paragraph{LParen und RParen - linke und rechte Klammer} Diese dienen dazu, Terme zu gruppieren und die eigentliche Operatorenreihenfolge zu verändern, wie es in der Mathematik üblich ist. Es werden die Zeichen ``('' und ``)'' erkannt.

\paragraph{Comma} Dient als Seperator von Funktionswerten.

\paragraph{Var und Func} Eine alphanumerische Zeichenkette, die zwingend mit einem Buchstaben beginnt. Klein- und Großschreibung sind gleichermaßen erlaubt. Die Namen beachten die Groß- und Kleinschreibung. Eine Funktion wird daran erkannt, dass nach der Zeichenkette eine öffnende Klammer ``('' anschließt, die zwingend wieder geschlossen werden muss.

\paragraph{Op} Mögliche Operatoren, es wird Beschränkt auf ``+, -, *, /, \^{}''. Der Typ Operator ist dabei wieder ein Enum, der diese Einträge enthält. Im Lexer werden noch keine Anpassungen des Terms vorgenommen.

\paragraph{Num} Eine Ganz- oder Fließkommazahl. Eine Fließkommazahl wird daran erkannt, dass das erste Zeichen ein ``.'' ist oder die gesamte geparste Zeichenkette einen ``.'' enthält. Es sind nur Zahlen erlaubt. Die E-Schreibweise $1.2E10$ wird nicht unterstützt.

\subsection{Implementierung Parser}
Als Parser kommt eine einfache Implementierung der Operator-Vorranganalyse in Frage, wie sie in Kurs 1810  Kurseinheit 3 Kapitel 3.3.2 beschrieben ist \cite[S. 83 ff.]{K1810}. Es handelt sich somit um eine Bottom-Up-Analyse. Dabei wird der Algorithmus so implementiert, dass der momentan gültige Operator in einer \codeword{while}-Schleife läuft, um einen Vektor befüllen zu können. Das erste Element des Vektors wird hierbei jeweils vor der Schleife geparst. Die restlichen Elemente in der Schleife selbst. Darüber hinaus werden Operatorenüberladungen des \codeword{Ast}-Enum verwendet.

Es handelt sich um einen LR(1)-Parser, da der Parser ein Zeichen vorrausschauen kann, um die nächste Aktion zu bestimmen. Der Stack ist im weitesten Sinne bereits ein gültiges \codeword{Ast}-Element, das befüllt wird. Die \codeword{shift}-Funktion kann als Voranschreiten im Iterator angesehen werden. Die \codeword{reduce}-Funktion entpricht dem Anwenden der Operatorenüberladungen auf dem gültigen \codeword{Ast}-Element.

Beim Parsing von Funktionsargumenten in mathematischen Ausdrücken fangen die Parameter dabei wieder mit der Funktion zum Parsen von ``+'' und ``-'' an. Auch werden bereits Variablen und Konstanten unterschieden. So enthält der Ast für den $a+\pi$ sowohl ``Ast::Symbol(``a'')'' als auch ``Ast::Const(``$\pi$'')''.

Darüber hinaus werden entsprechende Prüfungen eingebaut, sodass der Term $a+b+(c+d)$ nicht wie der folgende Baum geparst wird:

\Tree[.+
        [.a ]
        [.b ]
        [.+
            [.c ]
            [.d ]
        ]
    ]

Es entsteht vielmehr sofort der Baum:

\Tree[.+
        [.a ]
        [.b ]
        [.c ]
        [.d ]
    ]

\newpage

\section{Grundfunktionlitäten}
In diesem Abschnitt sollen grundlegende Funktionalitäten des CAS implementiert werden. Dies betrifft sowohl den Aufbau des Codes in Rust, um das CAS einfach erweiterbar zu machen, als auch das grundsätzliche Rechnen des Systems. So wird es beispielsweise keine Standardfunktionalität sein, dass $cos(x)^2+sin(x)^2 = 1$ erkannt wird. Dies soll über eine Erweiterung erkannt und verarbeitet werden. Das Zusammenfassen von $x+x=2*x$ ist hingegen aber eine Grundfunktionlität.

\subsection{Änderung des Terms mithilfe von Operatorenüberladung}
Der Trait \codeword{NumberType} soll bereits die meisten nötigen Operatorenüberladungen von den zu implementierenden Typen verlangen. Die wichtigsten Operationen sind \codeword{Add} und \codeword{Mul}, da diese vom CAS benutzt werden. Operatoren, die ebenfalls interessant im weiteren Verlauf sein können, sind der Modulo-Operator \codeword{Rem} (z.B. Auswertung der sin- oder cos-Funktion), aber auch die Möglichkeit Werte vergleichen zu können. Deshalb soll noch \codeword{PartialEq} und \codeword{PartialOrd} implementiert werden um die Funktionen ``NumberType == 1'' und ``NumberType > 1'' zu ermöglichen. Daraus ergibt sich die Definition und die Implementierungen für \codeword{PrimNum}:

\begin{lstlisting}[language=rust, caption={trait NumberType 1. Iteration}]
pub trait NumberType:
    + PartialEq<i128>
    + PartialOrd<i128>
    + ops::Add<Self, Output = Self>
    + ops::Mul<Self, Output = Self>
    + ops::Rem<i128, Output = Self>
{}

impl PartialEq<i128> for PrimNum { ,,, }
impl PartialOrd<i128> for PrimNum { ... }
impl ops::Add<PrimNum> for PrimNum { ... }
impl ops::Mul<PrimNum> for PrimNum { ... }
impl ops::Rem<i128> for PrimNum { ... }
\end{lstlisting}

Ebenfalls sollen für das Enum \codeword{Ast} Operatoren überladen werden. Hier beschränken wir uns auf die Operatoren ``Add'' und ``Mul''. Mit dem zusätzlichen Generic-Typ ergibt sich die Defintion:

\begin{lstlisting}[language=rust, caption={Ast Operatorenüberladung}]
impl<N> ops::Add<Ast<N>> for Ast<N>
where
    N: NumberType,
{ ... }

impl<N> ops::Mul<Ast<N>> for Ast<N>
where
    N: NumberType,
{ ... }
\end{lstlisting}

Die Überladungen für \codeword{Ast} sollen dabei gleich Zusammenfassungen übernehmen, falls möglich. Das bedeutet konkret für Addition und entsprechend für Multiplikation:

\begin{lstlisting}[language=rust, caption={Operatenüberladung für Addition}]
    Ast::Num(1) + Ast::Num(2) = Ast::Num(3)

    Ast::Add(vec![Ast::Symbol("a"), Ast::Symbol("b")]) +
    Ast::Add(vec![Ast::Symbol("c"), Ast::Symbol("d")]) = 
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Symbol("b"), 
                 Ast::Symbol("c"), Ast::Symbol("d")
                ]
        )

    Ast::Add(vec![Ast::Symbol("a"), Ast::Symbol("b")]) +
    Ast::Num(1) =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Symbol("b"), 
                 Ast::Num(1)
                ]
        )

    Ast::Add(vec![Ast::Symbol("a"), Ast::Num(2)]) +
    Ast::Num(1) =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Num(3)]
        )

    Ast::Add(vec![Ast::Symbol("a")]) +
    Ast::Anderes =
        Ast::Add(
            vec![Ast::Symbol("a"), Ast::Anderes]
        )

    Ast::Anderes +
    Ast::Anderes =
        Ast::Add(
            vec![Ast::Anderes, Ast::Anderes]
        )
\end{lstlisting}

\label{sec:kapAddnundMult}
\subsection{Addieren und Multiplizieren (Standardauswertung von Termen)}
Die prinzipielle Vorgehensweise um Additionen und Multiplikationen auszuführen, orientiert sich an dem Vorgehen aus SymPy (vgl. \cite{SymPyAddFlatten} und \cite{SymPyMulFlatten}). Beide Verfahren sind im Grunde identisch, nur ändert sich der entsprechende Operator und das Ergebnis. So wird aus $x+x$ eine Multiplikation der Form $2*x$. Aus $x*x$ wird die Potenz $x^2$. 

Das Verfahren wird exemplarisch für die Addition beschrieben, die Multiplikation wird aber ebenfalls im System implementiert. Kernstück ist eine \codeword{HashMap} deren Schlüssel und Werte vom Typ \codeword{Ast<N>} sind. Der Schlüssel ist hierbei der eigentliche Term, der in der Addition auftritt. Der Wert ist der Multiplikator wie häufig der Term auftritt. Zudem gibt es einige Sonderfälle. Als Beispiel dient der Term 
$2*x*y + x*y + 3 + a - a$. Um diesen zusammenzufassen, wird über alle Elemente des Vektors iteriert. Die HashMap ist zu Anfang leer, ein gesondertes ``Zahlenergebnis'' wird auf 0 gesetzt.

\begin{itemize}
    \item 1. Wert: Die Multiplikation ist gleich ein Sonderfall. Hier wird versucht eine Zahl aus dem Subterm zu extrahieren, dies ist hier möglich mit der $2$. Die HashMap erhält den Eintrag ``[x*y] = 2''
    \item 2. Wert: Wie davor wird wieder versucht eine Zahl zu extrahieren, was hier nicht gelingt. Bei der Multiplikation können wir also somit das neutrale Element 1 für diesen Subterm hinzufügen. Die HashMap erhält nun den aktualisierten Wert ``[x*y] = 3''
    \item 3. Wert: Alle Zahlen, also unser definierter Nummerntyp, können einfach zu dem Zahlenergebnis addiert werden. Hierzu wird einfach die bereits vorhandene Operatorenüberladung genutzt
    \item 4. Wert: Alle anderen Ausprägungen des \codeword{Ast}-Enum (in diesem Fall Symbol) werden ähnlich der Multiplikation behandelt, nur wird hierbei immer der Wert 1 addiert. Die HashMap erhält hier nun den Wert ``[a] = 1''
    \item 5. Wert: Augenscheinlich wieder ein Symbol. Allerdings wurde bereits erwähnt, dass diese Form intern als $+(-1*a)$ gespeichert wird. Also wird zur HashMap wieder eine Multiplikation hinzugefügt, die den Multiplikator ``-1'' hat. Somit wird die HashMap aktualisiert mit ``[a] = 0''
\end{itemize}

Nachdem diese Vereinfachungen in der HashMap gespeichert sind, besteht die Möglichkeit auf dieser HashMap durch externe Funktionen noch weitere Vereinfachungen vorzunehmen. Dieses Vorgehen wird noch genauer im Kapitel ``\hyperref[sec:kapErRustUndBei]{Erweiterbarkeit in Rust und Beispiele}'' näher erläutert.

Zum Schluss können die Ergebnisse wieder in die Ausprägung \codeword{Ast::Add} überführt werden. Das Zahlenergebnis kann hierbei einfach hinzugefügt werden. Bei der HashMap hängt dies vom Wert zum Key ab. 

\begin{itemize}
    \item Wert == 0: Key wird dem Vektor nicht hinzugefügt
    \item Wert == 1: Key wird dem Vektor hinzugefügt
    \item Alles andere: Es wird dem Vektor \codeword{Ast::Mul(vec![Wert, Key])} hinzugefügt
\end{itemize}

Um das Verfahren zu implementieren, müssen für das \codeword{Ast}-Enum noch die Traits \codeword{Eq}, \codeword{PartialEq} und \codeword{Hash} implementiert werden. Erst dann kann der Typ \codeword{Ast} als Schlüssel in der HashMap verwendet werden. Im den meisten Fällen kann die Implementierung über Makros erfolgen. In diesem Fall ist es aber nur für \codeword{PartialEq} möglich. Da z.B. Vektoren die Traits \codeword{Eq} und \codeword{Hash} nicht implementieren, müssen die Traits manuell implementiert werden. Der \codeword{Eq}-Trait ist dabei aber nur deklarativ, es muss keine Funktion ausgefüllt werden, dies übernimmt der Compiler \cite{RustEqTrait}. Der \codeword{Hash}-Trait kann ebenfalls recht einfach implementiert werden, hier können alle vorhandenen Werte als Hash zusammenfasst werden.

\subsection{Umgang mit Brüchen, Potenzen und Wurzeln}
Um auch genauere Werte zu erlauben, sollen rationale Zahlen in Form von Brüchen implementiert werden. So können mithilfe der Operatorenüberladungen diese dann zusammengefasst und gekürzt werden. Für rationale Zahlen sind im Enum \codeword{PrimNum} für Zähler und Nenner nur ganze Zahlen erlaubt, sowohl jeweils postiv und negativ. Der Term $1/3+1/3$ wird also zu \codeword{Num(Rational(2, 3))} ausgewertet. Der Term $1/3+1/3+1/3$ soll zu \codeword{Num(Int(1))} ausgewertet werden können.

Terme wie $1/x$ werden durch das CAS in die Form \codeword{Pow(Symbol("x"), Num(Int(-1)))} umgeformt. Dabei ist ``x'' entsprechend die Basis und ``-1'' der Exponent. In der Standardimplementierung soll es außerdem bereits möglich sein die Potenzregel $a^{b^{c}} = a^{(b*c)}$ anzuwenden. Durch die bisherige Implementierung der Multiplikation wird außerdem bereits die Potenzregel $x^a*x^b = x^{(a+b)}$ angewendet. Die letzte Regel $x^a*y^a = (x*y)^a$ soll wiederum als erweiterte Funktionalität implementiert werden, da hier eine andere Vorgehensweise bei dem Zusammenfassen des Terms notwendig ist, als die bisher implementierte und im Kapitel zur \hyperref[sec:kapAddnundMult]{Addition und Multiplikation} vorgestellte Vorgehensweise.

Ebenso können Wurzeln ebenfalls als Potenzen dargestellt werden, z.B. $\sqrt{2} = 2^{1/2}$ oder $\sqrt[3]{8} = 8^{1/3}$. So können alle bisherigen Regeln hierrauf einfach angewendet werden. Zudem sollen die Funktionen \codeword{sqrt} und \codeword{nthroot} im Term verwendet werden können, die dann entsprechende \codeword{Ast}-Elemente erzeugen.

Darüber hinaus wird derselbe Algorithmus wie in SymPy implementiert um zu prüfen, ob eine Wurzel eine perfektes Ergebnis liefert \cite{SymPyNewton}. Hierbei wird das ``Newtonverfahren'' genutzt, das Näherungswerte für die Nullstullen von nichtlinearen Gleichungssystemen findet \cite{NewtonDetail}. Bei dieser Implementierung wird der Wert näherungsweise bestimmt und danach überprüft, ob die Potenz aus dem Wert und der n-ten Wurzel den gesuchten Wert abbildet. In diesem Fall kann das entsprechende Element vereinfacht werden.

\label{sec:kapErRustUndBei}
\subsection{Erweiterbarkeit in Rust und Beispiele}
Um die Erweiterbarkeit des Systems zu gewährleisten wird das Struct \codeword{EvalFn} eingeführt. Ein Objekt des \codeword{struct} soll zur Evaluierung eines Terms mit angegeben werden. Die hinzugefügten Funktionen des entsprechenden Objekts können dann nach allen Standardoperationen den Term weiter vereinfachen, wie z.B. den angesprochenen Sonderfall $cos(x)^2+sin(x)^2 = 1$, und Konstanten falls gewünscht auswerten. Außerdem wird ein Standard-Objekt vom System bereitgestellt, dass bereits die gängigsten Vereinfachungen vornehmen kann.

\begin{lstlisting}[language=rust, caption={Defintion EvalFn}]
    pub struct EvalFn<N> {
        pub adders: Vec<fn(&mut HashMap<Ast<N>, Ast<N>>, &bool)>,
        pub muls: Vec<fn(&mut HashMap<Ast<N>, Ast<N>>, &bool)>,
        pub pows: Vec<fn(&Ast<N>, &Ast<N>, &bool) -> Option<Ast<N>>>,
        pub funcs: 
            HashMap<String, fn(&Vec<Ast<N>>, &bool) -> Option<Ast<N>>>,
        pub consts: HashMap<String, fn() -> Ast<N>>,
    }
\end{lstlisting}

\paragraph{Allgemeines} Da das Enum \codeword{Ast} bereits einen Generic-Parameter enthält, muss dieser ebenfalls bei EvalFn angegeben werden. Die Felder sind teils Vektoren, teils HashMaps, die entsprechende Funktionen zur Vereinfachung vorhalten. Der Parameter mit dem Typ \codeword{&mut HashMap<Ast<N>} \hyperref[sec:kapAddnundMult]{wurde bereits genauer vorgestellt}.

\paragraph{adders} Funktionen, die den Typ \codeword{Ast::Add} weiter vereinfachen können. So ist es möglich entsprechend die Einträge der \codeword{HashMap} zu überprüfen und zu verändern. Der zweite Parameter vom Typ \codeword{bool} gibt an, ob es sich um eine explizite Berechnung handelt. Dies wird relevant, wenn auch ungenaue Werte berechnet werden sollen.

\paragraph{muls} Funktionen, die den Typ \codeword{Ast::Mul} weiter vereinfachen können. Die Parameter sind identisch wie bereits bei \codeword{adders}. Dieses Feld ist der Vollständigkeit halber implementiert, da kein Beispielterm gefunden werden konnte, bei dem dies relevant ist.

\paragraph{pows} Funktionen, die die Basis und den Exponenten erhalten und auswerten können. So kann z.B. der Term $(x*4)^{(1/2)}$ zu $x^{(1/2)}*2$ vereinfacht werden. Auch hier gibt es wieder die Möglichkeit eine explizite Berechnung zu erzwingen. Diese Funktion besitzt darüber hinaus einen Rückgabewert, da der entsprechende \codeword{Ast} nicht direkt bearbeitet wird, da sich dieser auch in der Ausprägung verändern kann. In diesem Beispiel wird aus einem \codeword{Ast::Pow} ein \codeword{Ast::Mul}.

\paragraph{funcs} Funktionen, die angegebene Funktionen im Term umschreiben bzw. auswerten sollen. So kann z.B. der Term $sin(0) + 2$ direkt vereinfacht werden in $0 + 2 = 2$. Der Term $sqrt(4)$ kann zu $2$ vereinfacht werden. Dabei bleiben Funktionen, die \codeword{EvalFn} nicht bekannt sind natürlich im Term unverändert erhalten. Falls eine Auswertung nicht möglich ist, ist dies ebenfalls der Fall. Ansonsten steht der Funktion natürlich immer offen den Term entsprechend in ein anderes \codeword{Ast}-Objekt umzuwandeln. Dieses Feld ist als HashMap implementiert, da eine Funktion nur eine Auswertung besitzt.

\paragraph{consts} Funktionen die nur ein \codeword{Ast} zurückgeben. Dies wird in den meisten Fällen ein numerischer Wert sein. Dieses Feld ist ebenso als \codeword{HashMap} umgesetzt.

\subsection{Implementierung von Substitution} Um einen Term mit Variablen auszuwerten, müssen diese im \codeword{Ast}-Enum substituiert werden können. Diese Funktionalität kann recht einfach implementiert werden. Hierzu wird die bestehende \codeword{eval}-Methode erweitert, sodass nun auch Variablen überprüft werden. Als zusätzliche Parameter erhält die Methode einen Variablennamen und den zu substituierenden Term. Sind beide gesetzt und es handelt sich bei der Auswertung um die Variable, wird der Term anstelle der Variable zurückgegeben. Da Rust keine Methodenüberladung unterstützt, werden ebenfalls Methoden implementiert, die den Funktionsaufruf auch mit weniger Argumenten unterstützen und entsprechend Standardwerte übergeben, die keinen Einfluss auf die Berechnung haben.

Die Erweiterung der Methode besitzt zwei weitere Parameter, den optionalen Variablennamen, der ersetzt werden soll, und das entsprechend \codeword{Ast}, mit dem substituiert werden soll.
\begin{lstlisting}[language=rust, caption={Erweiterung pub fn eval}]
    pub fn eval_sub(
        &self,
        evaler: &EvalFn<N>,
        hard_eval: &bool,
        sub: &Option<&str>,
        with: &Option<&Ast<N>>,
    ) -> Ast<N> {
        match self {
            Ast::Add(vec) => add(
                vec.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Mul(vec) => mul(
                vec.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Pow(base, exp) => pow(
                base.eval_sub(evaler, hard_eval, sub, with),
                exp.eval_sub(evaler, hard_eval, sub, with),
                evaler,
                hard_eval,
            ),
            Ast::Func(name, args) => func(
                name,
                args.iter()
                    .map(|t| t.eval_sub(evaler, hard_eval, sub, with))
                    .collect(),
                evaler,
                hard_eval,
            ),
            Ast::Const(name) if *hard_eval => {
                let mut ret = None;
                for const_struct in evaler.consts.iter() {
                    if let Some(v) = const_struct.eval(&name) {
                        ret = Some(v);
                        break;
                    }
                }

                ret.unwrap_or(self.clone())
            }
            Ast::Symbol(name) if sub.is_some() && name == sub.unwrap() => 
                with.unwrap().clone(),
            _ => self.clone(),
        }
    }
\end{lstlisting}

Zu überlegen ist noch, ob der übergebene Term vor der Substituierung ebenfalls evaluiert wird, oder ob darauf vertraut wird, dass immer ein bereits evaluierter Term übergeben wird.

\subsection{Implementierung von expand}
Unter Umständen ist es interessant einen Term vereinfacht vorliegen zu haben. Auch wenn der Name ``expand'' nicht danach klingt, einen Term zu vereinfachen, so kann dies durchaus der Fall sein, wie der folgende Term zeigt $(x + 1)*(x - 2) - (x - 1)*x$ \cite{SymPyExpand}. Wird der Term ausmultipliziert kann dieser anschließend auf $-2$ vereinfacht werden. Im Folgenden sollen Terme auf dieser Art vereinfacht werden können.

\paragraph{Multiplikation von Additionen bzw. einzelnen Elementen} Hierbei soll der Term $x*(a+b)$ zu $x*a+x*b$ umgeformt werden, der Term $(a+b)*(c+d)*e$ soll entsprechend zu $a*c*e + a*d*e + b*c*e + b*d*e$ umgeformt werden.

Die Implementierung hiervon ist recht einfach. Bei der Ausprägung \codeword{Ast::Mul} wird ein leerer Ergebnisvektor erstellt. Danach muss über jedes Element im Vektor iteriert werden. Handelt es sich nicht um die Ausprägung \codeword{Ast::Add}, wird das Element dem Ergebnis hinzugefügt falls dieser noch leer ist. Ansonsten wird jedes Element im Ergebnisvektor mit dem derzeitigen Element multipliziert, dabei können die Elemente direkt im Vektor verändert werden.

Handelt es sich jedoch um die Ausprägung \codeword{Ast::Add} wird prinzipiell mit demselben Verfahren gearbeitet. Diesmal muss nur zusätzlich über alle Elemente im Vektor von \codeword{Ast::Add} iteriert werden um das derzeitige Element zu bestimmen. Die Veränderung kann nicht direkt im Vektor erfolgen, da ansonsten bereits der Ergebnisvektor verändert wird, bevor alle Elemente mit diesem multipliziert werden konnten.

\paragraph{Potenzen mit ganzzahligen positiven Exponenten} Bei Potenzen der Form $(x+y+z)^n, n \in \mathbb{N}$ kann die entsprechende Basis n-mal in den Vektor für \codeword{Ast::Mul} eingefügt werden. Hiernach kann die expand-Funktion für \codeword{Ast::Mul} aufgerufen werden um den Term auszumultiplizieren. 

\paragraph{Addition im Exponent} Potenzen der Form $n^{x+y}$ sollen in die Form $n^x*n^y$ überführt werden. Die Prüfung kann dabei durch eine einfache \codeword{match}-Anweisung erfolgen. Eine weitere Vereinfachung des Terms ist nach Fertigstellung nicht notwendig.

\paragraph{Potenzen mit Multiplikation in der Basis} Potenzen der Form $(x*y)^a$ sollen in die Form $x^a*y^a$ überführt werden. Die Prüfung kann dabei durch eine einfache \codeword{match}-Anweisung erfolgen.

\paragraph{Beispiel der Erweiterung an der log Funktion} Darüber hinaus soll es wieder einfach möglich sein, für mathematische Funktionen die \codeword{expand}-Methode aufrufen zu können. Hierzu wird das struct \codeword{EvalFn} erweitert.

\begin{lstlisting}[language=rust, caption={EvalFn nach expand}]
    pub struct EvalFn<N> {
        ...
        pub expand_funcs: 
            HashMap<String, fn(&Vec<Ast<N>>) -> Option<Ast<N>>>,
    }
\end{lstlisting}

Das neue Feld ``expand\_funcs'' enthält Funktionen um mathematische Funktionen zu expandieren. So soll z.B. aus $log(x^z*y)$ zu $z*log(x)+log(y)$ werden. Zuordnungen zu Funktionen finden wieder über eine HashMap statt.

\subsection{expand Implementierungshinweise}
Bei der Implementierung dieser Methode sind das strenge Typensystem von Rust als auch das Ownership und Borrowing in Erscheinung getreten. Explementarisch soll dies an zwei Beispielen erläutert werden, da sich dieses Verhalten ähnlich in anderen Fällen wiederholt.

Für das Enum \codeword{Ast} wurden die Methoden \codeword{shorten} und \codeword{sort} implementiert um generell die Handhabung des Typen zu verbessern. Beide Methoden erhalten eine veränderbare Referenz auf das eigene Objekt und geben auch solch eine wieder zurück. Die Implementierung von \codeword{expand} gibt allerdings eine eigenständige Instanz von \codeword{Ast} zurück und gibt somit das Ownership in diesem Fall ab. Da \codeword{Ast} nicht den Copy-Trait implementieren kann, kann der entsprechende Rückgabewert von \codeword{shorten} und \codeword{sort} nicht einfach dereferenziert werden.

Um das Problem zu umgehen bieten sich zwei Lösungen an. Einerseits kann das zurückgegebene Objekt mit \codeword{.clone()} geklont und als eigenständiges Objekt zurückgeben werden oder es werden die Funktionen auf dem Objekt aufgerufen um danach das Objekt als solches zurückgegeben.

\begin{lstlisting}[language=rust, caption={Mögliche Lösungen für Rückgabewerte}]
    // 1. Möglichkeit
    Ast::Add(result).shorten().sort().clone()

    // 2. Möglichkeit
    let mut result = Ast::Add(result);
    result.shorten().sort();

    result
\end{lstlisting}

Das zweite Beispiel bezieht sich auf das explizite Klonen des Exponenten bei Potenzen, wenn die Basis eine Multiplikation ist. In der entsprechenden for-Schleife wird für jedes Element des Vektors der Basis dem Ergebnis ein neues hinzugefügt nach den oben genannten Regeln. Der Exponent bleibt aber in jedem Durchlauf dersselbe. Da \codeword{Ast} einerseits nicht den Copy-Trait implementiert und andererseits die Initialisierung von Box das Ownership des Wertes bekommt, muss hier \codeword{.clone()} ausgeführt werden.

\subsection{Implementierung von simplify}
Um andere Arten von Vereinfachungen vorzunehmen, wird die Methode ``simplify'' in Anlehnung von SymPy \cite{SymPySimplify} erstellt. Hier werden verschiedene Möglichkeiten geprüft einen Term effizient zu vereinfachen.

In dieser Arbeit sollen folgende Terme vereinfacht werden können:

\begin{enumerate}
    \item $a^x * b^x$ wird zu $(a*b)^x$.
    \item $(x^3+x^2+x+1)/y/x*(y^2+y)/z$ wird zu $(x^2+x+1+\frac{1}{x})*(y+1)/z$ Wichtig hierbei ist, dass die Divisoren richtig zugeordnet werden und eine möglichst große Vereinfachung bewirken.
    \item Als Beispiel soll wieder die log-Funktion als Erweiterung implementiert werden. So wird aus $2*log(x)+log(b)$ der Term $log(x^2*b)$.
\end{enumerate}

Die zentrale Frage ist hierbei, wie die Komplexität eines Terms ermittelt wird. Die Standardimplementierung von SymPy zählt hierzu im Term die nötigen Operationen. So erhält der Term $(x**2+x+1)/y$ einen Wert von 4. In dieser Arbeit soll die Komplexität ebenfalls so ermittelt werden. Hierzu wird die Methode \codeword{count_ops} implementiert.

Da sich die ersten beiden Regeln zum Vereinfachen überschneiden können, soll darüber hinaus angegeben werden, welche Art der Vereinfachung durchgeführt werden soll.

\paragraph{Regel 1} Die am einfachsten zu implementierende Möglichkeit der Vereinfachung ist die erste Regel. Hierzu werden in einem \codeword{Ast::Mul} alle Werte iteriert und wie bereits in der Standardauswertung eine \codeword{HashMap} befüllt. Diesmal ist der Schlüssel allerdings der Exponent und der eigentliche Wert die Basis. Zum Schluss wird für jeden Eintrag entsprechend ein neues \codeword{Ast::Pow}-Element erzeugt und dem Ergebnis hinzugefügt.

\paragraph{Regel 2} Bei der zweiten Regel ist die Zuordnung der Divisoren zu den Additionstermen eine Schwierigkeit, die gelöst werden muss. Schlussendlich wurde eine Lösung gewählt, die jedem Divisor einem Dividenden zuordnet, die die größte Einsparung erbringt. Diese Kombination wird dann durchgeführt. Die Zuordnung läuft dabei so ab, dass alle möglichen Divisoren für alle möglichen Dividenden geprüft werden. Hierbei wird die Komplexität des Terms vor und nach Durchführung der Division gemessen und verglichen.

SymPy löst dies anders. Der Term $(x^3+x^2+x+1)/x*(x^2+x)$ wird hierbei ausmultipliziert und dann ein größter gemeinsamer Teiler gesucht (vgl. \cite{SymPySimplifySrc} Aufrufe \codeword{cancel}, \codeword{_mexpand}, \codeword{together}). Einerseits erscheint diese Möglichkeit sehr mächtig, aber auch recht komplex und fehleranfällig zu implementieren.

\label{sec:Regel2Simp}
Um die bisher gesammelte Erfahrung mit Rust in diese Arbeit zu bringen, wurde eine eigene Implementierung gewählt. Bei einem späteren Vergleich zwischen SymPy und diesem System können eventuelle Unterschiede aufgezeigt und verglichen werden.

\paragraph{Regel 3} Die letzte Regel soll es erlauben, benutzerdefinierte Regeln zur Zusammenfassung hinzuzufügen. Hierzu wird wieder das Struct \codeword{EvalFn} erweitert, um Funktionen hinzufügen zu können, die nacheinander aufgerufen werden. Als Beispiel dient hierbei die \codeword{log}-Funktion, die nun das Gegenteil von ``expand'' bewirkt. Eine Besonderheit hierbei ist, dass diese Funktion sowohl in Multiplikationstermen als auch in Additionstermen aufgerufen werden muss.

\subsection{simplify Implementierungshinweise}
Gerade bei der Implementierung der zweiten Regel ist der Aspekt ``Borrowing'' hervorgetreten. Die ursprüngliche Idee ist, im Term alle Summen und alle anderen Terme zu trennen. Hiernach sollte über alle Summen iteriert werden und der richtige Divisor gefunden werden. Sollte sich bei einer späteren Summe herausstellen, dass der Divisor eine größere Einsparung bringt, soll die vorherige Summe noch einmal mit anderen Divisoren überprüft werden. Allerdings ist es durch das ``Borrowing'' nicht möglich einem Vektor ein Element hinzuzufügen, über den gerade iteriert wird.

Die Lösung wird dabei folgendermaßen implementiert. Durch ein zweites Array wird gespeichert, ob es noch ein Element gibt, das überprüft werden muss. Dies geschieht durch einen ``bool''-Wert am entsprechenden Index. Nach der Iteration muss der entsprechende Index im Hilfsarray auf ``true'' gesetzt werden. Im Falle, dass der Divisor wechselt, muss der entsprechende Index auf ``false'' gesetzt werden. Die Schleife läuft dann solange wie ein ``false''-Wert im Hilfsarray vorhanden ist.

\newpage

\section{Erweiterte Funktionalitäten (Beispiele)}
Die bisherige Implementierung des CAS ist noch rudimentär. Es wurden lediglich die wichtigsten Eigenschaften implementiert um Terme möglichst weit und genau zusammenzufassen.
Die weiteren Implementierungen sollen nun einen Ausblick darauf geben, wie erweiterte Funktionalitäten implementitert werden können aufgrund der geschaffenen Basis. 

\label{sec:ungenauigkeitenKapitel}
\subsection{Terme mit Fließkommazahlen berechnen und Ungenauigkeit in Kauf nehmen} Um ein einzelnes numerisches Ergebnis zu erhalten, sofern alle Variablen im Term substitutiert sind, erhält das \codeword{Ast}-Enum zusätzlich die Methode \codeword{hard_eval}. Diese ruft die bereits vorgestellte Methode \codeword{eval_sub} auf und übergibt als Parameter, dass eine explizite Berechnung stattfinden soll. Dies kann mit einer gewissen Ungenaugkeit verbunden sein.

Der Parameter \codeword{hard_eval} soll dabei allen berechnenden Funktionen, insbesondere auch später hinzugefügten Funktionen, weitergegeben werden. Dies kann durch die Typdefinition \codeword{von EvalFn} sichergestellt werden.

Als konkretes Beispiel wird die bestehende Funktion \codeword{perfect_nth_root} erweitert. Als Rückgabewert ist das Enum \codeword{Option} angegeben worden. Bisher gibt diese Funktion \codeword{None} zurück, wenn es sich um kein exaktes Ergebnis handelt. Ansonsten wird ein entsprechendes \codeword{Ast}-Element zurückgegeben.

Wenn nun \codeword{hard_eval} auf ``true'' gesetzt ist, soll die Potenz ohne weitere Prüfung durchgeführt werden, falls es sich um Zahlen handelt. Dazu muss das trait \codeword{NumberType} noch die Methodendefinition \codeword{pow} forden, die in den eigenen Nummerntypen implementiert werden muss. In dem Fall von \codeword{PrimNum} werden die entsprechenden Rust-Funktionen der primitiven Typen aufgerufen um eine Potenz zu berechnen.

Als erstes Beispiel dient der Term $sqrt(2)$. Der Parser erkennt hierbei nur die Funktion. Bei einem Aufruf von \codeword{simple_eval} wird diese Funktion dann durch die bestehende Implementierung nach \codeword{Pow(Num(Int(2)), Num(Rational(1, 2)))} umgewandelt. Der Aufruf von \codeword{hard_eval} dagegen gibt den Fließkommawert \codeword{1.4142135623730951} zurück, wodurch bereits eine Ungenauigkeit entstanden ist.

Als zweites Beispiel dient der Term $sqrt(2)*sqrt(2)$. Durch die gewährleistete Ausführungsreihenfolge der Terme ist das Ergebnis mit \codeword{simple_eval} $2$. Dies kommt durch die Termzusammenfassung zustande, wie sie für die Addition erläutert ist. Bei der Ausführung mit \codeword{hard_eval} wird dagegen entsprechend das Ergebnis $2.0000000000000004$ zurückgegeben. Dies hat den Grund, da ja erst die Potenzen ausgeführt werden und danach erst die Multiplikation durchgeführt wird. Andere Nummerntypen, die hier eine höhere Genauigkeit erlauben bzw. solche Sonderfälle abfangen, können hierbei natürlich auch immer noch ein genaueres Ergebnis liefern.

\subsection{Implementierung der limit-Funktion}
Ursprünglich war geplant, dass die ``limit''-Funktion als Beispiel implementiert wird, wie dynamisch Funktionen dem CAS hinzugefügt werden können. Da dies aber tatsächlich bereits z.B. mit der Wurzelfunktion geschehen ist, kann sich auf die eigentliche Implementierung konzentriert werden. In dieser Arbeit werden nur einige Heuristiken der ``limit''-Funktion implementiert \cite{ListLimitHeuristic}.

Die Arbeit von Dominik Gruntz ``On Computing Limits in a Symbolic Manipulation System'' \cite{GruntzPdf} stellt darüber hinaus noch weitere Methoden vor, wie Limits berechnet werden können und besitzt einen eigenen Algorithmus, der neben Heuristiken in SymPy verwendet wird \cite{SympyLimitNote}. Die Implementierung dieser Verfahren soll nicht Teil dieser Arbeit sein.

Bei der Implementierung dieser Methode treten keine neuen Probleme mit dem Ownership und Borrowing von Rust auf. Es ist jederzeit nachvollziehbar, an welchen Stellen Werte geklont werden müssen. So müssen z.B. bei der Übergabe der Parameter bei einem rekursiven Funktionsaufruf diese geklont werden, da ansonsten entsprechend das Ownership abgegeben wird. Die bisherigen Implementierungen von \codeword{traits} zur Prüfung auf Gleichheit mit Ganzzahlen von \codeword{Ast} und \codeword{NumberType} sind auch hier ausreichend.

Als Ergänzung wurde die $\infty$-Konstante hinzugefügt, die nun auch während des Parsens erkannt wird. Darüber hinaus wurde die \codeword{shorten}-Methode erweitert, um \codeword{Add}- und \codeword{Mul}-Vektoren entsprechend zu behandeln, sofern die $\infty$-Konstante vorhanden ist. So wird z.B. $2*\infty$ zu $\infty$ vereinfacht.

\subsection{Terme leserlich darstellen}
Bisher wurde zur Ausgabe des Terms im \codeword{println!}-Makro der Platzhalter ``\{:?\}'' verwendet. Dieser erlaubt es \codeword{structs} und \codeword{enums} ohne weitere Formatierung auszugeben. In diesem Fall wird z.B. für den Term $-1+y+x*2+x^2$ die Ausgabe
\begin{quote}
    Add([Mul([Num(Int(2)), Symbol("x")]), Pow(Symbol("x"), Num(Int(2))), Symbol("y"), Num(Int(-1))])
\end{quote}
erzeugt. Da dies noch recht unleserlich ist und die übliche Notation die Potenz an den Anfang stellen würde, wird der Trait \codeword{Display} implementiert.

Sobald dieser implementiert ist, kann die Ausgabe auch mit \codeword{println!("{}", ast)} erfolgen. Für das Trait kann die Methode \codeword{fmt} überladen werden, die dann aufgerufen wird. Hier können die Vektoren von \codeword{Add} und \codeword{Mul} entsprechend sortiert werden, sodass eine übliche Ausgabe erfolgt. Die Implementierung in dieser Arbeit gibt für den oben genannten Term $x^2+2*x+y-1$ aus.

\newpage

\section{Vergleich zu SymPy}
In diesem Kapitel sollen die Korrektheit und Performance überprüft werden. Hierzu werden einige Beispielrechnungen festgelegt und ausgeführt. Ein Vergleich zu SymPy lässt eine Einordnung zu anderen Systemen zu.

\subsection{Korrektheit und Unterschiede gegenüber SymPy}
Um beurteilen zu können, ob das entwickeltes System richtig rechnet, soll mit verschiedenen Termen geprüft werden, ob SymPy diesselben Ergebnisse berechnet. Unterschiede zwischen Ergebnissen werden näher betrachtet.

\begin{table}[ht!]
    \caption{Numerische Berechnungen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $1+2+3+4-5$ & $5$ & $5$ \\
        \hline
        $1*2*3*4$ & $24$ & $24$ \\
        \hline
        $1*2*3*4*0$ & $0$ & $0$ \\
        \hline
        $1*2*3*4*(-1)$ & $-24$ & $-24$ \\
        \hline
        $2+3*4+5$ & $19$ & $19$ \\
        \hline
        $(2+3)*(4+5)$ & $45$ & $45$ \\
        \hline
        $2^{3^4}$ & $2417851639229258349412352$ & $2417851639229258349412352$ \\
        \hline
        $0.1+0.2$ & $0.30000000000000004$ & $0.300000000000000$ \\
        \hline
        $3^{-1} + 3^{-1}$ & $\frac{2}{3}$ & $\frac{2}{3}$ \\
        \hline
        $3^{-1} * 3^{-1}$ & $\frac{1}{9}$ & $\frac{1}{9}$ \\
        \hline
        $\sqrt{2}$ & $2^\frac{1}{2}$ & $\sqrt{2}$ \\
        \hline
        $\sqrt{2}+\sqrt{2}$ & $2*2^\frac{1}{2}$ &  $2*\sqrt{2}$ \\
        \hline
        $\sqrt{2}*\sqrt{2}$ & $2$ & $2$ \\
        \hline
    \end{tabular}
\end{table}

Bei dieser Gegenüberstellung fallen zwei Unterschiede auf. Zum einen tritt das Anfangs beschriebene Problem der Ungenauigkeit auf. Eine Lösung hierfür ist die Benutzung von \hyperref[sec:NumTypes]{PrecisionNum}.

\begin{lstlisting}[language=rust, caption={PrimNum vs. PrecisionNum}]
    let a1 = Ast::Num(PrimNum::Float(0.1));
    let a2 = Ast::Num(PrimNum::Float(0.2));
    println!("{}", a1 + a2);
    // 0.30000000000000004

    let a1 = Ast::Num(PrecisionNum::Float(
            BigDecimal::from_str("0.1").unwrap()));
    let a2 = Ast::Num(PrecisionNum::Float(
            BigDecimal::from_str("0.2").unwrap()));
    println!("{}", a1 + a2);
    // 0.3
\end{lstlisting}

Der zweite Unterschied ist die Ausgabe von $\sqrt{2}$. In implementierten System wird diese als Potenz ausgegeben, in SymPy als Funktion. Diese Darstellung ist aber nur kosmetisch. Wird der Term in SymPy mit \codeword{sympy.srepr(expr)} ausgegeben, ist die Struktur des Terms zu sehen. SymPy wandelt die $sqrt$-Funktion ebenfalls in eine Potenz um und gibt diese in diesem speziellen Fall formatiert aus.

\newpage

\begin{table}[ht!]
    \caption{Terme mit Variablen zusammenfassen}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $x+x+2*x$ & $4*x$ & $4*x$ \\
        \hline
        $2*x-x-x+y$ & $y$ & $y$ \\
        \hline
        $x+x+a*x$ & $a*x+2*x$ & $a*x + 2*x$ \\
        \hline
        $a*x-x-x+y$ & $a*x-2*x+y$ & $a*x - 2*x + y$ \\
        \hline
        $x*0$ & $0$ & $0$ \\
        \hline
        $x*x$ & $x^2$ & $x^2$ \\
        \hline
        $x^2*x$ & $x^3$ & $x^3$ \\
        \hline
        $x^a*x$ & $x^{a+1}$ & $x*x^a$ \\
        \hline
        $x/x$ & $1$ & $1$ \\
        \hline
        $x^2/x$ & $x$ & $x$ \\
        \hline
        $x^a/x$ & $x^{a-1}$ & $x^a/x$ \\
        \hline
        $a*x+b*x$ & $a*x+b*x$ & $a*x+b*x$ \\
        \hline
        $a^x*b^x$ & $a^x*b^x$ & $a^x*b^x$ \\
        \hline
        $x^a*x^b$ & $x^{a+b}$ & $x^a*x^b$ \\
        \hline
    \end{tabular}
\end{table}

Bei der Zusammenfassung von Variablen tritt ein Unterschied bei den Termen $x^a*x$, $x^a/x$ und $x^a*x^b$ auf. In diesem System werden, durch die implementierte Logik, vermehrt Potenzen zusammengefasst, was in SymPy standardmäßig nicht der Fall ist.

\begin{table}[ht!]
    \caption{Terme mit Variablen substituieren}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $2+x$, $x=3$ & $5$ & $5$ \\
        \hline
        $2+x$, $x=-3$ & $-1$ & $-1$ \\
        \hline
        $2-x$, $x=-3$ & $5$ & $5$ \\
        \hline
        $2+x$, $x=0.5$ & $2.5$ & $2.50000000000000$ \\
        \hline
        $2^{x} + 2^{x}$, $x=2$ & $8$ & $8$ \\
        \hline
        $2^{x} + 2^{x}$, $x=-1$ & $1$ & $1$ \\
        \hline
        $\sqrt{x}$, $x=3$ & $3^{\frac{1}{2}}$ & $sqrt(3)$ \\
        \hline
        $\sqrt{x}$, $x=4$ & $2$ & $2$ \\
        \hline
        $\sqrt{x}$, $x=16$ & $4$ & $4$ \\
        \hline
        $\sqrt{x}$, $x=17$ & $17^{\frac{1}{2}}$ & $sqrt(17)$ \\
        \hline
    \end{tabular}
\end{table}

Die Substituierung wird ebenfalls identisch umgesetzt. Einzig die Ausgabe bei Termen mit Wurzeln ist wie bereits erwähnt unterschiedlich.

\newpage

\begin{table}[ht!]
    \caption{Nutzung der Methode ``expand''}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $(x + 1)*(x - 2) - (x - 1)*x$ & $-2$ & $-2$ \\
        \hline
        $(a+b)*(c+d)*e$ & \makecell{$a*c*e+a*d*e$ \\ $+b*c*e+b*d*e$} & \makecell{$a*c*e + a*d*e$ \\ $ + b*c*e + b*d*e$} \\
        \hline
        $(a+b)^3$ & \makecell{$a^3+b^3+3*a^2*b$ \\ $+3*b^2*a$} & \makecell{$a^3 + 3*a^2*b + 3*a*b^2$ \\ $+ b^3$} \\
        \hline
        $x^{a+b}$ & $x^a*x^b$ & $x^a*x^b$ \\
        \hline
        $x^{a*b}$ & $x^{a*b}$ & $x^{a*b}$ \\
        \hline
        $(x+y)^a$ & $(x+y)^a$ & $(x + y)^a$ \\
        \hline
        $(x*y)^a$ & $x^a*y^a$ & $x^a*y^a$ \\
        \hline
        $log(x^2*y)$ & $2*log(x)+log(y)$ & $2*log(x) + log(y)$ \\
        \hline
        $log(x^a*y)$ & $a*log(x)+log(y)$ & $a*log(x) + log(y)$ \\
        \hline
    \end{tabular}
\end{table}

Terme, die mit ``expand'' in beiden Systemen verarbeitet werden, liefern jeweils das gleiche Ergebnis. Dies ist natürlich nur der Fall, für die in diesem System implementierten Funktionen. Andere mathematische Funktionen, die von SymPy korrekt verarbeitet werden, müssten erst nachimplementiert werden. So werden in SymPy ebenfalls trigonomische Funktionen ausgewertet. Es wird aus $sin(2*x)$ der Term $2*sin(x)*cos(x)$ \cite{SympyTrigExpand}.

\begin{table}[ht!]
    \caption{Nutzung der Methode ``simplify''}
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Term} & \textbf{Ergebnis CAS} & \textbf{Ergebnis SymPy} \\
        \hline
        $(x^2 + x)/x$ & $x + 1$ & $x + 1$ \\
        \hline
        $(x^2 + x)*(y^2 + y)/x/y$ & $(y + 1)*(x + 1)$ & $(x + 1)*(y + 1)$ \\
        \hline
        $(x^2 + x)*(y^2 + y)/x/a$ & $a^-1*(x+1)*(y^2+y)$ & $y*(x + 1)*(y + 1)/a$ \\
        \hline
        $(x^3 + x^2 + x)*(x^2 + x)/x$ & $(x^2+x)*(x^2+x+1)$ & $x*(x + 1)*(x^2 + x + 1)$ \\
        \hline
    \end{tabular}
\end{table}

Auch bei der Nutzung von ``simplify'' erhalten wir gleichwertige Ergebnisse. SymPy klammert zusätzlich aber noch gemeinsame Teiler aus, was unser System nicht beherrscht. Dies sieht man vor allem am dritten Beispiel. Beide Terme sind aber in diesem Fall korrekt. Dieser Fall wurde bereits bei der \hyperref[sec:Regel2Simp]{Implementierung von ``simplify''} erwähnt.

\subsection{Performancevergleich}
Bei diesem Vergleich soll die Laufzeit, der Speicherverbrauch und die CPU-Auslastung in verschiedenen Szenarien verglichen werden. Die verwendete Hardware besteht aus einem ``AMD Ryzen 5 3600X 6-Core Processor'' und 16 GB Arbeitsspeicher mit 3000 MHz (DDR 4). Als Messtool wird die Windows-Version des ``Benchmarks Game'' verwendet \cite{BenchmarkGameHome} \cite {BenchmarkGameSrc}.

Python liegt hierbei aus den offiziellen Quellen in Version 3.9.7 vor \cite{PythonDownload}, der Rust-Compiler besitzt die Version ``rustc 1.60.0'' und wurde mithilfe von ``rustup'' installiert \cite{RustDownload}. Die verwendeten ausführbaren Programme wurden als Release-Version kompiliert und so geschrieben, dass der Compiler die Berechnungen nicht wegoptimiert.

Alle Szenarien werden zehn mal ausgeführt und dargestellt. Die Zeiten sind in Sekunden angegeben, der Speicherverbrauch in Kilobyte und die CPU-Auslastung in Prozent.

\paragraph{1. Szenario} Hier werden alle Berechnungen des vorherigen Kapitels durchgeführt. Alle Terme werden dabei sowohl in SymPy als auch in Rust aus einer Zeichenkette geparst und entsprechend ausgeführt.

\begin{table}[ht!]
    \caption{Performance Tests}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 0.625 & 40560 & 6 & 0.000 & 756 & 0 \\
        \hline
        2 & 0.688 & 40488 & 6 & 0.000 & 764 & 0 \\
        \hline
        3 & 0.641 & 40548 & 6 & 0.016 & 768 & 0 \\
        \hline
        4 & 0.641 & 40692 & 6 & 0.000 & 752 & 0 \\
        \hline
        5 & 0.609 & 40576 & 6 & 0.000 & 756 & 0 \\
        \hline
        6 & 0.641 & 40324 & 6 & 0.000 & 756 & 0 \\
        \hline
        7 & 0.609 & 40636 & 5 & 0.000 & 752 & 0 \\
        \hline
        8 & 0.641 & 40648 & 7 & 0.000 & 752 & 0 \\
        \hline
        9 & 0.594 & 40808 & 6 & 0.016 & 772 & 0 \\
        \hline
        10 & 0.641 & 40712 & 6 & 0.000 & 756 & 0 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{2. Szenario} Der Term $a+b+c$ wird einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49 und jede Variable mit einem Schleifenzähler substituiert. Die erste Substitution ist somit $0+0+0$, die zweite $0+0+1$ und die letzte $49+49+49$.

\begin{table}[ht!]
    \caption{Performance Addition}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 9.781 & 37796 & 8 & 0.453 & 740 & 7 \\
        \hline
        2 & 9.656 & 37612 & 8 & 0.469 & 732 & 8 \\
        \hline
        3 & 9.859 & 37768 & 8 & 0.438 & 732 & 8 \\
        \hline
        4 & 9.688 & 37760 & 8 & 0.453 & 752 & 8 \\
        \hline
        5 & 9.734 & 37960 & 8 & 0.469 & 756 & 8 \\
        \hline
        6 & 9.766 & 37696 & 8 & 0.453 & 744 & 8 \\
        \hline
        7 & 9.875 & 37740 & 8 & 0.469 & 712 & 8 \\
        \hline
        8 & 9.594 & 37920 & 8 & 0.438 & 736 & 8 \\
        \hline
        9 & 9.609 & 37912 & 8 & 0.453 & 740 & 8 \\
        \hline
        10 & 9.688 & 37964 & 8 & 0.469 & 736 & 8 \\
        \hline
    \end{tabular}
\end{table}

\newpage

\paragraph{3. Szenario} Der Term $a*b*c$ wird einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49 und jede Variable mit einem Schleifenzähler substituiert. Die erste Substitution ist somit $0*0*0$, die zweite $0*0*1$ und die letzte $49*49*49$.

\begin{table}[ht!]
    \caption{Performance Multiplikation}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 12.594 & 37996 & 8 & 0.344 & 792 & 7 \\
        \hline
        2 & 12.812 & 37460 & 8 & 0.344 & 744 & 8 \\
        \hline
        3 & 12.906 & 37852 & 8 & 0.344 & 740 & 8 \\
        \hline
        4 & 12.797 & 37596 & 8 & 0.344 & 740 & 8 \\
        \hline
        5 & 12.719 & 37508 & 8 & 0.359 & 744 & 8 \\
        \hline
        6 & 12.812 & 37856 & 8 & 0.344 & 752 & 8 \\
        \hline
        7 & 12.922 & 37536 & 8 & 0.344 & 744 & 8 \\
        \hline
        8 & 12.547 & 37744 & 8 & 0.344 & 744 & 8 \\
        \hline
        9 & 12.672 & 37424 & 8 & 0.328 & 752 & 8 \\
        \hline
        10 & 12.922 & 37576 & 8 & 0.344 & 744 & 7 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{4. Szenario} In diesem Szenario liegt der Fokus auf den Speicherverbrauch. Es wird wieder der Term $a+b+c$ einmalig erstellt. Hiernach werden drei geschachtelte for-Schleifen durchlaufen, jeweils von 0 bis 49. Einer am Anfang erstellten Liste bzw. Vektor wird dann sowohl der originale Term als auch die Substituierung wie im 2. Szenario hinzugefügt.

\begin{table}[ht!]
    \caption{Speicherverbrauch}
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
        \textbf{Lauf} & \textbf{Python Zeit} & \textbf{Speicher} & \textbf{CPU} & \textbf{Rust Zeit} & \textbf{Speicher} & \textbf{CPU} \\
        \hline
        1 & 9.703 & 42608 & 8 & 0.578 & 43792 & 7 \\
        \hline
        2 & 9.891 & 41680 & 8 & 0.484 & 43748 & 7 \\
        \hline
        3 & 9.797 & 42496 & 8 & 0.500 & 43784 & 7 \\
        \hline
        4 & 9.578 & 41668 & 8 & 0.516 & 43788 & 7 \\
        \hline
        5 & 9.750 & 42444 & 8 & 0.500 & 43752 & 8 \\
        \hline
        6 & 9.719 & 42280 & 8 & 0.500 & 43796 & 8 \\
        \hline
        7 & 9.781 & 42448 & 8 & 0.516 & 43792 & 7 \\
        \hline
        8 & 9.734 & 41792 & 8 & 0.500 & 43744 & 7 \\
        \hline
        9 & 9.750 & 42360 & 8 & 0.516 & 43736 & 7 \\
        \hline
        10 & 9.656 & 42552 & 8 & 0.516 & 43792 & 7 \\
        \hline
    \end{tabular}
\end{table}

\paragraph{Beobachtungen} Bei einem Vergleich der Szenarien 1 bis 3 ist wie zu erwarten das kompilierte Programm sowohl schneller als auch speichereffizienter. Der geringe Speicherverbrauch in Rust lässt sich einerseits auf das automatische Deallokieren von Variablen zurückführen, wenn diese den Gültigkeitsbereich verlassen. Andererseits gibt es keine Laufzeitumgebung wie in Python. Bei den SymPy-Tests dagegen ist der große Sprung zum Speicherplatzverbrauch auf die SymPy-Bibliothek zurückzuführen.

Wird ein einfaches ``Hello World!'' in Python ausgegeben, beträgt der Speicherverbrauch ca. 5000 Kilobyte. Wird im selben Python-Skript zusätzlich SymPy importiert, beträgt der Speicherverbrauch bereits ca. 35000 Kilobyte. Da zudem unklar ist, wann genau der Garbage Collector von Python läuft, kann es auch vorkommen, dass noch ungenutzte Variablen den Speicher belegen.

Im ausführbaren Programm von Rust, sind dagegen nur Codeabschnitte, die tatsächlich benögit werden. Nicht benötigte Funktionen aus Abhängigkeiten und dem eigenen Code sind nicht vorzufinden \cite{RustDeadCode1}. Dies kann man sich auch anschaulich mit ``cargo-bloat'' anzeigen lassen \cite{RustDeadCode2}.

Bei Szenario 4 zeigt die Laufzeit wieder ein ähnliches Verhältnis, Rust ist wieder schneller als SymPy. Auf den ersten Blick skaliert aber SymPy wesentlich besser in Bezug auf den Speicherplatzverbrauch. Dies ist aber stark implementierungsabhängig. Da wie anfänglich beschrieben immer der originale Term und das Ergebnis der Liste hinzugefügt wird, muss aufgrund des Ownerships in Rust der originale Vektor immer kopiert werden, da dieser nur einmalig erstellt wird. Bei dem Hinzufügen zur Liste wird dann das Ownership verschoben.

Fügt man in der Python-Version anstelle des originalen Terms die Adresse der Variablen der Liste hinzu und lässt sich diese ausgeben, fällt auf, dass immer nur eine Referenz hinzugefügt wird, da alle Adressen identisch sind. Lediglich die Ergebnisse unterscheiden sich. Wird der originale Term nicht der Liste hinzugefügt, beträgt der Speicherplatzverbrauch von Rust nur noch ca. 13000 Kilobyte, die Python-Version belegt immer noch ca. 40000 Kilobyte.

Anstelle einer kopierten Version des Terms könnte auch eine Referenz der Liste hinzugefügt werden. Dann muss aber wiederrum sichergestellt werden, dass dieser eine größere Lifetime als der Vektor besitzt.

Aus den Ergebnissen kann geschlossen werden, dass Rust im Vergleich zu SymPy eine wesentlich bessere Performance bietet. Dies betrifft zum einen die Laufzeit von Berechnungen, als auch den Speicherplatzverbrauch. Letzteres hängt aber natürlich von den implementierten und verwendeten Funktionen des Systems ab.

\newpage

\section{Fazit}
\subsection{Erweiterungs- und Verbesserungsideen des Systems}
Im Rahmen dieser Arbeit wurde nicht für alle Implementierungen die bestmögliche Lösung vorgenommen. Auch sind einige Aspkete verbesserungswürdig, die für einen angenehmeren Umgang mit dieser Bibliothek sorgen würden. Diese Punkte sollen der Vollständigkeit halber mit aufgeführt werden.
\begin{itemize}
    \item Da Rust keine weiteren Optimierungen für Rekursion bietet, würde eine iterative Lösung die Elemente des \codeword{Ast} zu verarbeiten wahrscheinlich Performanter sein.
    \item Der Parser könnte erweitert werden, sodass auch $3x$ anstelle von $3*x$ erkannt wird. Auch die Möglichkeit dynamisch Operatoren hinzuzufügen wäre interessant, sodass z.B. für die Fakultät einfach $x!$ angegeben werden kann, anstelle eines Funktionsaufrufs.
    \item Bei der Zusammenfassung der Terme ist zu überlegen, den Nummerntyp nicht zusammenzufassen. Rationale Zahlen und Fließkommazahlen könnten nebeneinander existieren. In der momentanen Implementierung wird diese Addition zu einer Fließkommazahl vereinfacht. Der Vorteil dabei ist, dass sicher nur ein Zahlenwert vorhanden ist. Allerdings wird der Nachteil der Ungenauigkeit in Kauf genommen.
    \item Bei der Zusammenfassung von Termen in der HashMap kann es zu Konflikten kommen. Eine andere Idee wäre als Schlüssel den Term als String zu verwenden. Hierzu müsste aber der Term auf jeden Fall vorher sortiert sein. Permutationen eines Terms ($x*y$ und $y*x$) können sonst nicht abgefangen werden. Hier hat das Hashing den Vorteil, das die Reihenfolge egal ist, da beide Symbole zusammen denselben Hashwert errechnen.
    \item Im Moment wird $cos(x)^2+sin(x)^2 = 1$ nur in einfachen Fällen zusammengefasst. Der Term $(z*sin(x)^2)+(z*cos(x)^2) + (a*sin(x)^2)+(a*cos(x)^2)$ könnte entsprechend auch zusammengefasst werden.
    \item Erweiterung des heuristischen Verfahrens der ``limit''-Funktion und Implementierung des Gruntz-Algorithmus \cite{GruntzPdf}.
\end{itemize}

Bei der Substituierung von Symbolen wären ebenfalls Erweitungen vorstellbar.
\begin{itemize}
    \item Übergabe eines Vektors von Werten, Rückgabewert ist ebenfalls Vektor mit den entsprechenden Substituierungen. Diese könnten sogar nebenläufig umgesetzt werden.
    \item Mehrere Variablen gleichzeitig ersetzen.
    \item Substitution von ganzen Termen erlauben, nicht nur einzelnen Variablen.
    \item Mischformen der Verbesserungen.
\end{itemize}

\subsection{Ausblick}
Am Anfang dieser Arbeit waren die Konzepte Ownership, Borrowing und Lifetimes noch schwer greifbar. Diese wurden als Hürde wahrgenommen, da hierdurch einige Implementierungen  explizit angegeben werden müssen, wie z.B. das Klonen von Übergabeparametern oder auch wie teilweise über Elemente iteriert werden muss. Im Laufe der Entwicklung des CAS wurden diese Konstrukte aber immer augenscheinlicher und bereiteten schlussendlich keine Probleme mehr. Darüber hinaus kann immer leicht nachvollzogen werden, an welchen Stellen welche Werte verwendet werden mit der Sicherheit, dass diese nicht versehentlich an anderer Stelle überschrieben worden sind. Die Fehleranfälligkeit sinkt dadurch wie in \hyperref[sec:kap3d2]{Kapitel 3.2} gezeigt.

Dieses strenge System in Rust hat sich von einem Nach- zu einem großen Vorteil entwickelt. Verbunden mit einer steilen Lernkurve von Rust sind dies die einzigen Nachteile, die während der Arbeit mit Rust aufgefallen sind.

Ein weiterer Vorteil von Rust ist die bessere Performance im Gegensatz zu SymPy. Dieser Vorteil dürfte im Vergleich zu anderen Systemen, die in C oder C++, wie z.B. Xcas \cite{XcasLink} geschrieben sind, geringer ausfallen. Das hängt im konkreten Fall vom verwendeten Compiler ab, der die ausführbaren Programme erzeugt. Da Rust, wie bereits angesprochen, LLVM verwendet, würde ein C/C++ Programm kompiliert mit Clang eine ähnliche Performance aufweisen.

Ebenfalls ein Vorteil ist das breite Ökosystem, welches mit ``cargo'' bereitsteht. Das Programm kann einfach mit verschiedenen Profilen kompiliert werden, z.B. als Debug- oder Releaseversion. Abhängigkeiten können installiert und Tests und Bechnmarks einfach ausgeführt werden.

Auch wenn, wie Eingangs erwähnt, Rust derzeit keine große Relevanz im Bereich des wisschenschaftlichen Arbeitens besitzt, so sprechen die genannten Punkte dafür, Rust auch dort zu verwenden. Wie ebenfalls in der Einleitung erwähnt wird die Sprache in anderen Projekten erfolgreich eingesetzt.

Gerne veröffentliche nach Absprache mit Frau Prof. Dr. Oden die entstandene Arbeit und stelle diese der Rust-Community zur Verfügung. Eine zukünftige Weiterentwicklung soll nicht ausgeschlossen werden.

\newpage
\bibliographystyle{babplain-fl}
\raggedright
\bibliography{literature}

\end{document}
